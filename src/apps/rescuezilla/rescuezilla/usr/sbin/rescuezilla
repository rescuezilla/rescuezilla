#!/usr/bin/perl -w
# ----------------------------------------------------------------------
#   Rescuezilla
#   A simple GUI interface that allows bare-metal backup and restore.
# ----------------------------------------------------------------------
#   Copyright (C) 2019 Rescuezilla.com
# ----------------------------------------------------------------------
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# ----------------------------------------------------------------------

use strict;
use warnings;
use Glib qw{ TRUE FALSE };
use Gtk2 '-init';
use XML::Simple;
use Gtk2::SimpleList;
use IO::Handle;
use Data::Dumper;
use Sys::CPU;
use POSIX qw(locale_h);
use locale;
use utf8;
use Method::Signatures::Simple;
use String::ShellQuote;
use Capture::Tiny ':all';
use File::Tee qw(tee);

# Ensures standard input/output handled with UTF-8 encoding
binmode(STDOUT, ":utf8");
binmode(STDERR, ":utf8");

my $log_date=`date '+%Y%m%dT%H%M%S'`;
chomp($log_date);
my $log_filename="rescuezilla.log.$log_date.txt";
my $quoted_tmp_log_path = shell_quote("/tmp/$log_filename");
# Ensure STDERR autoflushes buffer, to workaround supposed Perl File::Tee bug: https://rt.cpan.org/Public/Bug/Display.html?id=128168
STDOUT->autoflush(1);
STDERR->autoflush(1);
# Ensures all output automatically written to temp log file, as well as STDOUT/STDERR. This particular
# file does not persist between reboots (and Rescuezilla normally runs in a non-persistent environment),
# but it forms the basis of the log placed in the backup destination directory.
tee(STDOUT, { prefix => 'STDOUT: ', autoflush => 1, lock => 1, mode => '>>', open => $quoted_tmp_log_path });
tee(STDERR, { prefix => 'STDERR: ', autoflush => 1, lock => 1, mode => '>>', open => $quoted_tmp_log_path });

# Load translation
use constant TRANSLATION_DIR => "/usr/share/rescuezilla/translations-rescuezilla/";
my $lc_messages = setlocale(LC_MESSAGES);
# Extract the ISO 639-1 code
my $lang_code = substr($lc_messages,0,2);
print "LC_MESSAGES locale:             $lc_messages.\n";
print "Attempting to load translation: ".TRANSLATION_DIR."$lang_code.po\n\n";

# Exports 'loc'
use Locale::Maketext::Simple (
    Path => TRANSLATION_DIR,
    Decode => 1,
    # Use gettext %1 variable interpolation/substitution than maketext's [_1] style,
    # as maketext's style wasn't working for all strings (possibly due to encoding issues)
    Style => 'gettext',
);

# Sets language to the LC_MESSAGES environment variable
loc_lang($lang_code);

##### Constants found in our program ###################################
use constant VERSION         => `cat /usr/share/rescuezilla/VERSION`;
use constant COMMIT_DATE     => `cat /usr/share/rescuezilla/GIT_COMMIT_DATE`;
use constant CD_LABEL        => `cat /usr/share/rescuezilla/TITLE`;
use constant MOUNT_POINT     => "/mnt/backup";
use constant DATA_DIR        => "/usr/share/rescuezilla/";
use constant APP_ICON        => DATA_DIR."redobackup-icon.png";
use constant GLADE_UI        => "rescuezilla.glade";
use constant MAX_WIDTH       => 96;
use constant FS_SUPPORT      => ( "ext2",
                                  "ext3",
                                  "ext4",
                                  "fat",
                                  "fat12",
                                  "fat16",
                                  "fat32",
                                  "jfs",
                                  "vfat",
                                  "ntfs",
                                  "hfsp",
                                  "reiser4",
                                  "reiserfs",
                                  "ufs",
                                  "vmfs",
                                  "xfs" );

my @BACKUP_STEPS  = ( loc("Step 1: Select Source Drive"),
                      loc("Step 2: Select Partitions to Save"),
                      loc("Step 3: Select Destination Drive"),
                      loc("Step 4: Select Destination Folder"),
                      loc("Step 5: Name Your Backup"),
                      loc("Creating Backup Image"));
my @RESTORE_STEPS = ( loc("Step 1: Select Backup Drive"),
                      loc("Step 2: Select Backup Image"),
                      loc("Step 3: Select Drive To Restore"),
                      loc("Restoring From Backup" ));
my @USB_STEPS     = ( loc("Step 1: Select Destination Drive"),
                      loc("Step 2: Install to USB Drive" ));

my $msg = "";

#### get number of cpu threads to use
my $number_of_cpus = Sys::CPU::cpu_count();
my $numthreads = $number_of_cpus - 1;

if ($numthreads <= "1") {
$numthreads = 1;
}

sub default_share_name {
    my $share = `cat /etc/rescuezilla/share`;
    chomp $share;
    return $share;
}

sub allow_source_overwrite {
    my $overwrite = not (-e "/etc/rescuezilla/no_source_overwrite");
    return $overwrite;
}

func max(@values) {
  if (!@values) { return -INF; }
  my $max = $values[0];
  foreach my $val (@values) {
    if ($val > $max) { $max = $val ; }
  }
  return $max;
}

func fdisk_units($text) {
  my @matches = ( $text =~ /unit: ([^[:space:]]+)/g );
  my $count = @matches;
  if (@matches  < 1) { return undef; }
  if (@matches == 1) { return $matches[0]; }
  my $same = 'TRUE'; foreach my $unit (@matches) { $same = ($same and ($unit eq $matches[0])); }
  if ($same) { return $matches[0]; }
  else { return undef; }
}

func parttab($text) {
  my @text = split("\n", $text);
  my %parts;
  foreach my $line (@text) {
    my @match = ($line =~ /^[[:blank:]]*(\/dev\/[[:alnum:]]+|-)[[:blank:]]+:[[:blank:]]*start=[[:blank:]]*([[:digit:]]+), size=[[:blank:]]*([[:digit:]]+), type=[[:blank:]]*([[:xdigit:]]+)/);
    if (@match && $match[3]) {
      if (((length $match[0]) < 3) || !$match[2]) {
        print "Error on line: " . $line;
        print "\n";
      }
      my %res = (start => $match[1], length => $match[2], id => hex($match[3]), end => ($match[1]+$match[2]));
      $parts{$match[0]}= \%res;
    }
  }
  foreach my $part (keys %parts) {
    print $part . " ";
    foreach my $val (keys %{$parts{$part}}) {
      print $val . ": " . ${$parts{$part}}{$val} ."\t";
    }
    print  "\n";
  }
  return \%parts;
}

func partends($text) {
  my %parts = %{parttab($text)};
  foreach my $part (keys %parts) {
    $parts{$part} = ${$parts{$part}}{'end'} * 512;
  }
  return \%parts;
}

##### Test code ########################################################
#$ARGV[0] = 'restore';


##### Main code ########################################################
$| = 1;
main();
exit(0);


##### Subroutines and callbacks ########################################
sub main {
  # Start the main application
  our $builder;
  my $window;
  $builder = Gtk2::Builder->new();
  # Load translations to strings in the Glade file.
  print("Setting GTK translation domain to load files from eg, /usr/share/locale/${lang_code}/LC_MESSAGES/rescuezilla.mo\n");
  $builder->set_translation_domain("rescuezilla");
  $builder->add_from_file(DATA_DIR.GLADE_UI);
  $window = $builder->get_object('main_app');
  $builder->connect_signals(undef);
  # Change the background of the header to white
  my $eventbox = $builder->get_object('main_image_eventbox');
  $eventbox->modify_bg('GTK_STATE_NORMAL', Gtk2::Gdk::Color->new(0xffff,0xffff,0xffff));
  $builder->get_object('main_tabs')->set_show_tabs(FALSE);
  $builder->get_object('backup_tabs')->set_show_tabs(FALSE);
  $builder->get_object('backup_tabs')->set_show_border(FALSE);
  $builder->get_object('restore_tabs')->set_show_tabs(FALSE);
  $builder->get_object('restore_tabs')->set_show_border(FALSE);
  $builder->get_object('usb_tabs')->set_show_tabs(FALSE);
  $builder->get_object('usb_tabs')->set_show_border(FALSE);
  my $ver = VERSION;
  chomp($ver);
  # Get the memory bus width (that is, 32 or 64 bit computing). End-users are expected to read the term "64bit",
  # but cannot be expected to read the intimidating term Linux distribution arch 'i386'/'amd64' (which is also
  # misleading as Debian/Ubuntu's i386 version is actually i686). Nor do users need to read the "machine hardware name"
  # 'i686'/'x86_64' (from `arch` or `uname -m`).
  my $memory_bus_width = `getconf LONG_BIT`;
  chomp($memory_bus_width);
  $memory_bus_width = $memory_bus_width."bit";
  my $commit_date = COMMIT_DATE;
  chomp($commit_date);
  my $human_readable_version = "$ver ($memory_bus_width) $commit_date";
  set_status("Version $human_readable_version");
  print("Rescuezilla version is $human_readable_version\n");
  # Print more OS information, to help debug problems from users using the frontend downloaded
  # from their distro's package manager, rather than Rescuezilla's controlled environment
  my $lsb_release = `lsb_release -a`;
  print("lsb_release -a:\n$lsb_release");
  my $uname_a = `uname -a`;
  print("uname -a:\n$uname_a");
  $window->maximize();
  $window->show();
  my $mode = '';
  if (defined($ARGV[0])) { $mode = $ARGV[0]; }
  if ($mode eq 'backup') { backup_mode(); }
  if ($mode eq 'restore') { restore_mode(); }
  my $welcome = loc("Welcome to Rescuezilla");
  my $tools_msg = loc("Many other tools are available from the Start menu in the bottom left corner");
  system("notify-send '${welcome}' '${tools_msg}' -i info");
  # Log message are usually relevant only to developers, no need to localize them, especially as enduser may not familiar with Linux.
  print "Disabling swap partitions\n";
  # Ensure swap is turned off during every launch. Potential gotcha: GParted
  # reportedly re-enables swap.
  system("swapoff --all");
  Gtk2->main;
}


##### Backup Logic #####################################################
sub backup_mode {
  # Enter Backup mode
  our %status;
  $status{'action'} = 'backup';
  backup_step(1);
}

sub backup_step {
  # Advance to the next Backup Step
  my $step = $_[0];
  if (!defined($step)) { $step = 1; }
  our $builder;
  our %status;
  set_main_title(loc("Backup"));
  $builder->get_object('main_tabs')->set_current_page(1);
  $step = $builder->get_object('backup_tabs')->get_current_page()+1;
  set_subtitle($BACKUP_STEPS[$step-1]);
  if ($step == 1) {
    # Backup Step 1
    find_local_drives();
    print_drive_list();
    set_drive_dropdown('backup_source');
    $builder->get_object('backup_button_next')->set_sensitive(TRUE);
  } elsif ($step == 2) {
    # Backup Step 2
    $status{'backup_drive'} = $builder->get_object('backup_source')->get_active_text();
    set_partition_list('backup_partitions', $status{'backup_drive'});
    $builder->get_object('backup_button_next')->set_sensitive(TRUE);
  } elsif ($step == 3) {
    # Backup Step 3
    backup_dest_changed();
    set_partition_dropdown('backup_dest_local');
    set_share_dropdown('backup_dest_network');
    $builder->get_object('backup_button_next')->set_sensitive(TRUE);
  } elsif ($step == 4) {
    # Backup Step 4
    $builder->get_object('backup_button_next')->set_sensitive(FALSE);
    if ($builder->get_object('backup_dest_use_local')->get_active()) {
      my ($type, $source) = split(/\|/, $builder->get_object('backup_dest_local')->get_active_text());
      $status{'mount_type'} = $type;
      $status{'mount_source'} = $source;
    } else {
      my ($type, undef) = split(/\|/, $builder->get_object('backup_dest_network')->get_active_text());
      $status{'mount_type'} = $type;
      $status{'mount_source'} = $builder->get_object('backup_dest_server')->get_text();
      $status{'mount_user'} = $builder->get_object('backup_dest_user')->get_text();
      $status{'mount_pass'} = $builder->get_object('backup_dest_pass')->get_text();
      $status{'mount_domain'} = $builder->get_object('backup_dest_domain')->get_text();
      $status{'mount_version'} = $builder->get_object('backup_dest_version')->get_text();
    }
    my $mount_ok = 0;
    my $mount_cmd = "";
    my $mount_stderr_msg = "";
    ($mount_ok, $mount_cmd, $mount_stderr_msg) = &mount_data();
    if ($mount_ok==0) {
      my $failed_to_access_drive_msg =  loc("Could not access the destination drive:\n\n%1", $mount_stderr_msg);
      # The error message printed by the mount command provides a more descriptive explanation about why the network mount failed
      # (eg, could not resolve address for XYZ), but is sometimes only available in English. Also network mounts configured by technical users
      # may be used by non-technical users.
      my $check_username_password_msg =  loc("Please ensure the username, password and other fields provided are correct, and try again.");
      my $internal_mount_cmd_msg =  loc("The mount command used internally was: `%1`", $mount_cmd);
      if (($status{'mount_type'} =~ /SMB/) or ($status{'mount_type'} =~ /FTP/)) {
        message_box("$failed_to_access_drive_msg\n\n$check_username_password_msg\n\n$internal_mount_cmd_msg");
      } else {
        message_box("$failed_to_access_drive_msg");
      }
      $step = $builder->get_object('backup_tabs')->set_current_page(2);
      set_subtitle($BACKUP_STEPS[2]);
    } else  {
      $builder->get_object('backup_folder')->set_text('/');
      $builder->get_object('backup_folder_browse')->grab_focus();
      my $free_mb = get_free_space(1);
      if ($free_mb < 1000) { message_box(loc("Warning! This drive has only %1MB of free space. Make sure your backup will fit.", $free_mb)); }
    }
    $builder->get_object('backup_button_next')->set_sensitive(TRUE);
  } elsif ($step == 5) {
    # Backup Step 5
    my (undef,undef,undef,$d,$m,$y,undef,undef,undef) = localtime(time);
    $y = sprintf("%04d", $y+1900);
    $m = sprintf("%02d", $m+1);
    $d = sprintf("%02d", $d);
    $builder->get_object('backup_name')->set_text("$y$m$d");
    $builder->get_object('backup_name')->grab_focus();
    $builder->get_object('backup_button_next')->set_sensitive(TRUE);
  } elsif ($step == 6) {
    # Backup Step 6
    $builder->get_object('backup_button_next')->hide();
    # Start the process
    refresh_window();
    sleep(0.25);
    do_backup();
  }
  refresh_window();
}


sub backup_scan_network {
  # Scan the network and add shares to list
  scan_network('backup_dest_network');
}

sub backup_dest_changed {
  # The destination was changed (local/network)
  our $builder;
  my $local = $builder->get_object('backup_dest_use_local')->get_active();
  if ($local!=1) {
    $builder->get_object('backup_frame_local')->hide();
    $builder->get_object('backup_frame_network')->show();
  } else {
    $builder->get_object('backup_frame_network')->hide();
    $builder->get_object('backup_frame_local')->show();
  }
  refresh_window();
}

sub backup_dest_network_changed {
  # The network dest was changed
  our $builder;
  my $share = $builder->get_object('backup_dest_network')->get_active_text();
  if (defined($share)) {
    my ($type, $server) = split(/\|/, $share);
    my $server_editable = TRUE;
    my $domain_editable = TRUE;
    my $version_editable = TRUE;
    if ($server eq '') {
      if ($type eq 'FTP') {
        # It's a manually-entered FTP share
        $server = get_subnet();
        $server =~ s/\d+$//g;
      } else {
        # It's a manually-entered SMB share
        $server = default_share_name;
      }
    } else {
      # It's an automatically-found share
      $server =~ s/^smb:|^ftp:\/\///g;
      $server_editable = FALSE;
    }
    if ($type ne 'SMB') {
      $domain_editable = FALSE;
      $version_editable = FALSE;
    }
    $builder->get_object('backup_dest_server')->set_text($server);
    $builder->get_object('backup_dest_server')->set_sensitive($server_editable);
    $builder->get_object('backup_dest_domain')->set_sensitive($domain_editable);
    $builder->get_object('backup_dest_version')->set_sensitive($version_editable);
  }
}

sub do_backup {
  # Begin the backup process
  our %drives;
  our %status;
  our $builder;
  # TODO: Overhaul this application to remove use of global variables to share state.
  our $tee_stdout_pid;
  our $tee_stderr_pid;
  $builder->get_object('backup_progress')->set_sensitive(TRUE);
  # Get partition selections and output folder
  my $src = $status{'backup_drive'};
  my $dest = MOUNT_POINT.$builder->get_object('backup_folder')->get_text();
  # Remove trailing forward slash (if any)
  $dest =~ s/\/$//;
  # Ensure log file persists between reboots by copying the temp log file into backup destination
  # and continue logging stdout/stderr.
  my $quoted_destination_log_path = shell_quote("$dest/$log_filename");
  system("cp $quoted_tmp_log_path $quoted_destination_log_path");
  $tee_stdout_pid = tee(STDOUT, { prefix => 'STDOUT: ', autoflush => 1, lock => 1, mode => '>>', open => $quoted_destination_log_path });
  $tee_stderr_pid = tee(STDERR, { prefix => 'STDERR: ', autoflush => 1, lock => 1, mode => '>>', open => $quoted_destination_log_path });
  print "*** ".loc("Backup %1 to %2",$src, $dest)." ***\n\n";
  my $file = $builder->get_object('backup_name')->get_text();
  my $enduser_drive_number = get_enduser_drive_number($src);
  my ($base_device, $partition_number) = split_device_string($src);
  my $src_drive = "/dev/$base_device";
  # Sanity check filename was valid for this filesystem
  # TODO: Ideally a sanity check to this effect would occur while the user is typing the filename, and not cause a fatal crash.
  my $touch_stdout = "";
  my $touch_stderr = "";
  my $touch_retcode = "";
  my $quoted_tmp_sanity_check = shell_quote("$dest/$file.test.file");
  ($touch_stdout, $touch_stderr, $touch_retcode) = capture { system("touch $quoted_tmp_sanity_check") };
  print("touch command stdout: $touch_stdout\ntouch command stderr: $touch_stderr\n");
  my $touch_sanity_check_failed_msg = loc("Failed to write destination file. Please confirm it is valid to create the provided file path, and try again.");
  fatal_crash($touch_sanity_check_failed_msg."\n\n$touch_stdout\n$touch_stderr") unless ($touch_retcode eq 0);
  system("rm $quoted_tmp_sanity_check");
  # Save partition table
  my $quoted_sfdisk_file = shell_quote("$dest/$file.sfdisk");
  # Backup partition table. Works whether MBR-formatted or GPT-formatted disk.
  # TODO: Evaluate use of sgdisk, which my be more appropriate for robust GPT backup/restore
  my $sfdisk_cmd = "sfdisk --reorder --dump '$src_drive' > $quoted_sfdisk_file";
  print("Saving partition table: $sfdisk_cmd\n");
  system($sfdisk_cmd);
  my $ptab = `cat $quoted_sfdisk_file`;
  print("Saved partition table: $ptab\n");
  # Extract the number sectors until first partition (sfdisk seems to report 512 byte sectors even on 4K sector disks)
  # On MBR only disks, this is the "post-MBR gap" which contains GRUB2's core.img (known as stage 1.5 on GRUB legacy).
  my $partition1_sector_offset = `grep 'start=' $quoted_sfdisk_file | head --lines 1 | sed 's_.*start=[[:space:]]*__g' | sed 's_,.*__g'`;
  $partition1_sector_offset = trim($partition1_sector_offset);
  # Sanity check that the regex and calculation did not fail.
  if (("$partition1_sector_offset" cmp "") == 0) {
     print("Warning: Unable to calculate offset to first partition.\n");
     # If the calculation did fail for some reason continue to proceed, but assuming large 1MiB post-MBR gap alignment.
     $partition1_sector_offset=2048;
  }
  # Want all sectors from start of disk until the sector before the first partition.
  my $num_sectors_to_partition1=$partition1_sector_offset - 1;
  my $quoted_mbr_file = shell_quote("$dest/$file.mbr");
  # Copy all bytes before the first partition. This gets the MBR, Primary GPT (if any) and on MBR systems ensures 
  # the post-MBR gap is fully backed up (which often contains GRUB2 core.img bootloader or GRUB Legacy stage 1.5 bootloader).
  # For whatever reason, the Sector number calculated by sfdisk is always in terms of 512 byte sectors even on 4K sector disks.
  my $dd_cmd = "dd if='$src_drive' of=$quoted_mbr_file bs=512 count=$num_sectors_to_partition1";
  print("Saving Master Boot Record (MBR) and any GRUB stage 1.5 loader: $dd_cmd\n");
  system($dd_cmd);

  # This error is unlikely to ever occur on the Rescuezilla ISO image, but may occur if a user runs the frontend on misconfigured environments.
  my $fdisk_units_wrong_msg = loc("Partition table output malformed: fdisk units must be sectors. Are all pre-requisites correctly installed?");
  fatal_crash($fdisk_units_wrong_msg) unless (fdisk_units($ptab) eq 'sectors');
  print "\t* ".loc("MBR and partition table of %1 saved to %2",$src_drive,$dest)."\n";
  # Save size of source drive in blocks
  my $blockdev_cmd = "/sbin/blockdev --getsize64 '$src_drive'";
  print("Running $blockdev_cmd\n");
  my $bytes = `$blockdev_cmd`;
  print("Unprocessed blockdev output: $bytes\n");
  $bytes =~ s/\D//g;
  # Get the byte offset of the end of the last partition selected
  my $ptab_bytes = max(values(%{partends($ptab)}));
  print "partition table reports drive size $ptab_bytes\n";
  # This error is unlikely to ever occur on the Rescuezilla ISO image, but may occur if a user runs the frontend on misconfigured environments.
  my $blockdev_ptab_mismatch_msg = loc("blockdev reports smaller drive size %1 than determined from partition table %2", $bytes, $ptab_bytes);
  fatal_crash($blockdev_ptab_mismatch_msg) unless $bytes >= $ptab_bytes;
  $bytes = $ptab_bytes;
  my $quoted_filesize_path = shell_quote("$dest/$file.size");
  my $save_filesize_cmd = "echo $bytes > $quoted_filesize_path";
  print("Running $save_filesize_cmd\n");
  system($save_filesize_cmd);
  print("Running $save_filesize_cmd\n");
  system($save_filesize_cmd);
  print "\t* ".loc("Size of %1 (%2 bytes) saved to %3",$src_drive,$bytes,$quoted_filesize_path)."\n";
  print "Getting selected partitions\n";
  # Save list of partitions we will be backing up
  my @partlist = get_selected_partitions('backup_partitions');
  print "Saving selected partitions to file\n";
  save_partition_list(\@partlist, "$dest/$file.backup");
  # Get the total bytes we're going to be saving
  #print Dumper(%drives);
  my $total_bytes = 0;
  foreach my $part (@partlist) {
    my $enduser_drive_number = get_enduser_drive_number($part);
    my ($base_device, $partition_number) = split_device_string($part);
    my $part_bytes = $drives{$base_device}{'parts'}{$partition_number}{'bytes'};
    $total_bytes += $part_bytes;
  }
  $status{'start'} = time();
  $status{'part_list'} = \@partlist;
  $status{'last_part'} = $partlist[-1];
  $status{'total_parts'} = scalar(@partlist);
  $status{'current_part'} = 0;
  $status{'total_bytes'} = $total_bytes;
  $status{'done_bytes'} = 0;
  $status{'frame'} = 0;
  $status{'free'} = get_free_space();
  print "\t* ".loc("Total partitions to save: %1",$status{'total_parts'})."\n";
  print "\t* ".loc("Total bytes to save: %1",$status{'total_bytes'})."\n";
  # Create backup by calling progress sub
  Glib::Timeout->add(50, \&update_backup_progress);
  refresh_window();
}

sub update_backup_progress {
  # Update the backup progress bar
  our $PROGRESS;
  our %drives;
  our %status;
  our $builder;
  # TODO: Overhaul this application to remove use of global variables to share state.
  our $tee_stdout_pid;
  our $tee_stderr_pid;
  my $progress_bar = $builder->get_object('backup_progress');
  my $data = undef;
  our $i;
  my $part = $status{'part_list'}[$status{'current_part'}];
  my $enduser_drive_number = get_enduser_drive_number($part);
  my ($base_device, $partition_number) = split_device_string($part);
  my $src = $status{'backup_drive'};
  my $dest = MOUNT_POINT.$builder->get_object('backup_folder')->get_text();
  $dest =~ s/\/$//;
  my $file = $builder->get_object('backup_name')->get_text();
  my $fs = lc($drives{$src}{'parts'}{$partition_number}{'fstype'});
  # Write the Rescuezilla version to a file to help future versions best handle future backwards-compatibility
  my $version = VERSION;
  chomp($version);
  my $quoted_backup_version_file = shell_quote("$dest/$file.rescuezilla.backup_version");
  system("echo '$version' > $quoted_backup_version_file");
  # See if the filehandle is open
  if (!defined($PROGRESS)) {
    # No command is being executed
    my $tool = "";
    my $extra_args = "";
    ($tool, $extra_args) = &which_backup_tool($fs);
    check_command("$tool --version");
    # Write the exact partclone command used to create the backup of the current partition. This tool is required during restore.
    my $quoted_partition_tool = shell_quote("$dest/$file.partclone.command.part$partition_number");
    system("echo '$tool' > $quoted_partition_tool");
    set_status(loc("Preparing to create backup of Drive %1, Part %2...",$enduser_drive_number, $partition_number));
    print "*** ".loc("Processing %1 (%2) using %3...",$part,$fs,$tool)."\n";
    umount_warn_on_busy("/dev/$part");
    my $quoted_partition_log_file = shell_quote("/${dest}/${file}_part${partition_number}_partclone.log");
    my $quoted_partition_split_prefix = shell_quote("/${dest}/${file}_part${partition_number}.");
    my $backup_cmd = "( $tool $extra_args -F -L $quoted_partition_log_file -s '/dev/$part' | pigz -c --fast | split -d -a 3 -b 2048m - $quoted_partition_split_prefix ) 2>&1 |";
    print "*** ".loc("Executing: ")."$backup_cmd\n";
    open $PROGRESS, "$backup_cmd";
    sleep(0.5);
    return TRUE;
  } else {
    # Read available data and append it to $status{'command_output'} until a newline is reached
    my $char = '';
    do {
      $char = getc($PROGRESS);
      if (!defined($char)) {
        return 1;
      } else {
        if (($char eq "\n") || ($char eq "\r") || (ord($char)==27)) {
          undef($char);
        } else {
          $status{'command_output'} .= $char;
        }
      }
    } while (defined($char));
  }
  # Try to read command progress and append it to the data
  $data = $status{'command_output'};
  undef($status{'command_output'});
  if (defined($data)) {
    # Remove newlines and lines that are all spaces
    $data =~ s/\n|\r|\[A|^\s+$//g;
    refresh_window();
    $i++;
    # Split it up and show the results    
    if ($data =~ m/Starting to clone device/) {
      # Starting a filesystem
      my (undef, $current_part) = split(/\(\/dev\//, $data);
      $current_part =~ s/\).*$//g;
      $status{'current_part_device'} = $current_part;
      print ">>> ".loc("Starting to clone %1",$status{'current_part_device'})."\n";
      print ">>> ".loc("List of partitions:")."\n";
      foreach my $item (@{$status{'part_list'}}) {
        $msg = '';
        if ($item eq $current_part) { $msg = loc("(Processing)"); }
        print "\t* $item $msg\n";
      }
    } elsif ($data =~ m/Device size: /) {
      # Device size reported
      my (undef, $dev_size) = split(/: /, $data);
      $dev_size =~ s/^\s+|\s+$//g;
      print(">>> ".loc("Device size: %1",$dev_size)."\n");
    } elsif ($data =~ m/Space in use: /) {
      # Device used space reported
      my (undef, $dev_used) = split(/: /, $data);
      $dev_used =~ s/^\s+|\s+$//g;
      print(">>> ".loc("Space in use: %1",$dev_used)."\n");
    } elsif ($data =~ m/^.*\.c.*: /) {
      # A warning was encountered
      my (undef, $warning) = split(/: /, $data);
      print(">>> ".loc("Warning: %1", $warning)."\n");
      set_status(loc("Warning: %1", $warning));
    } elsif ($data =~ m/Reading Super Block/) {
      print(">>> ".loc("Reading super block")."\n");
      set_status(loc("Reading super block for Drive %1, Part %2...",$enduser_drive_number,$partition_number));
    } elsif ($data =~ m/Calculating bitmap/) {
      print(">>> ".loc("Calculating bitmap")."\n");
      set_status(loc("Calculating bitmap for Drive %1, Part %2...",$enduser_drive_number,$partition_number));
    } elsif ($data =~ m/Elapsed.+\%$/) {
      # Calculating bitmap, percentage given
      #Elapsed: 00:00:03, Remaining: 00:00:00, Completed:  93.41%
      my $elapsed = substr($data,9,8);
      my $remaining = substr($data,30,8);
      my $pct = substr($data,51,6);
      $pct =~ s/\s+//g;
      $msg = loc("Reading bitmap for part %1 of %2",$status{'current_part'}+1,$status{'total_parts'});
      $builder->get_object('backup_progress_status')->set_text($msg);
      print ">>> ".loc("Calculating bitmap progress: %1% Remaining: %2",$pct,$remaining)."\n";
      set_status(loc("Reading bitmap for Drive %1, Part %2 (%3% done, %4 remaining)",$enduser_drive_number,$partition_number,$pct,$remaining));
    } elsif ($data =~ m/Elapsed.+,$/) {
      # Backup progress line
      $status{'frame'}++;
      if ($status{'frame'} >= 10) {
        $status{'frame'} = 0;
        $status{'free'} = get_free_space();
      }
      my $elapsed = substr($data,9,8);
      my $remaining = substr($data,30,8);
      my $pct = substr($data,51,6);
      my $rate = substr($data,60,12);
      $pct =~ s/\s+//g;
      $rate =~ s/\s+//g;
      print ">>> ".loc("Elapsed: *%1* | Remaining: *%2* | Percent: *%3* | Speed: *%4*",$elapsed,$remaining,$pct,$rate)."\n";
      $msg = loc("Part %1 of %2 (%3%) %4 Elapsed %5 Remaining",$status{'current_part'}+1, $status{'total_parts'},$pct,$elapsed,$remaining);
      $builder->get_object('backup_progress_status')->set_text($msg);
      # Base overall percentage on number of total bytes
      my $current_bytes = int(($pct/100) * $drives{$src}{'parts'}{$partition_number}{'bytes'}) + $status{'done_bytes'};
      my $overall_pct = ($current_bytes / $status{'total_bytes'}) + (($pct / 100) / $status{'total_bytes'});
      if ($overall_pct > 1) { $overall_pct = 1; }
      set_status(loc("Saving part %1 (%2) at %3 (%4 free space)", $status{'current_part'}+1, $drives{$src}{'parts'}{$partition_number}{'size'},$rate,$status{'free'}));
      print ">>> ".loc("Drive: %1 | Partition: %2 | Current bytes: %3 | Overall: %4",$src,$partition_number,$current_bytes,$overall_pct)."\n";
      $progress_bar->set_fraction($overall_pct);
      $msg = loc("%1% Complete", sprintf("%.2f", $overall_pct * 100));
      $progress_bar->set_text($msg);
    } elsif (($data =~ m/successfully cloned/) || ($data =~ m/Cloned successfully./)) {
      set_status(loc("Partition completed."));
      print ">>> ".loc("Partition %1 completed.", $status{'current_part_device'})."\n";
      print "\t".loc("Current part: %1",$status{'current_part'}+1)."\n";
      print "\t".loc("Total parts: %1",$status{'total_parts'})."\n";
      if ($status{'current_part'}==$status{'total_parts'}-1 ) {
        $builder->get_object('backup_progress_status')->set_text('');
        $progress_bar->set_fraction(1);
        set_status(loc("Backup complete."));
        my @lines = split(/\n/, $data);
        my $start = FALSE;
        $builder->get_object('backup_button_cancel')->set_label(loc('Exit'));
        refresh_window();
        # Unmount stuff
        system("sync");
        sleep(0.5);
        beeper('done');
        my $elapsed = sprintf("%.1f", (time()-$status{'start'})/60);
        message_box(loc("Backup image saved in %1 minutes.", $elapsed));
        $msg = loc("Backup saved successfully.");
        system("notify-send -i ".APP_ICON." '${msg}'");
        print ">>> Operation complete.\n";
        print("Stopping logging so that destination directory can be unmounted\n");
        system("sync");
        # FIXME: Appears to close the entire STDERR/STDOUT streams (which are used for more logs than just this one file).
        # FIXME: This is sufficient for now as exits after backup complete so nothing further to log.
        # FIXME: Need to understand the exact reasons and fix the File::Tee library if required.
        my $cnt = kill('HUP', $tee_stdout_pid, $tee_stderr_pid);
        if ($cnt != 2) {
          print("Failed to stop logging in destination directory. Killing destination log.\n");
          kill('KILL', $tee_stdout_pid, $tee_stderr_pid);
        }
        umount_warn_on_busy(MOUNT_POINT);
        return 0;
      } else {
        close $PROGRESS;
        undef($PROGRESS);
        # Need to add the size of the partition to the total bytes completed
        $status{'done_bytes'} += $drives{$src}{'parts'}{$partition_number}{'bytes'};
        print ">>> Backed up $status{'done_bytes'} of $status{'total_bytes'} total bytes.\n";
        $status{'current_part'}++;
        print ">>> Advancing to next partition.\n";
        return TRUE;
      }
    } else {
      if (length($data)>0) {
        print "$data\n";
        if ($data =~ m/error|warning/i) {
          error_message($data);
        }
      }
    }
  }
  return TRUE;   
}

sub backup_name_changed {
  # Make sure the backup name is valid
  our $builder;
  my $val = FALSE;
  my $backup_name = $builder->get_object('backup_name')->get_text();
  if ($backup_name ne '') {
    $val = TRUE;  
  } else {
    $val = FALSE;
  }
  $builder->get_object('backup_button_next')->set_sensitive($val);
}

sub select_backup_folder {
  # Open the folder selection dialog
  our $builder;
  my $folder_chooser = Gtk2::FileChooserDialog->new(loc("Select a Folder"), $builder->get_object('main_app'), "select-folder", loc("Cancel") => "cancel", loc("Save Here") => "ok");
  $folder_chooser->set_modal(TRUE);
  $folder_chooser->set_current_folder(MOUNT_POINT."/".$builder->get_object('backup_folder')->get_text());
  my $response = $folder_chooser->run();
  if ($response eq 'ok') {
    my $current_folder = $folder_chooser->get_current_folder();
    if (substr($current_folder,0,length(MOUNT_POINT)) eq MOUNT_POINT) {
      $current_folder = substr($current_folder,length(MOUNT_POINT));
      if ($current_folder eq '') { $current_folder = '/'; }
    } else {
      error_message(loc("You must select a folder inside %1",MOUNT_POINT).chr(13).chr(13).loc("Please select a different folder."));
      $current_folder = '/';
    }
    $builder->get_object('backup_folder')->set_text($current_folder);
  }
  $folder_chooser->destroy();
}


##### Restore Logic ####################################################
sub restore_mode {
  # Enter Restore mode
  our %status;
  $status{'action'} = 'restore';
  restore_step(1);
}

sub restore_step {
  # Advance to the next Restore Step
  my $step = $_[0];
  if (!defined($step)) { $step = 1; }
  our $builder;
  our %status;
  set_main_title(loc("Restore"));
  $builder->get_object('main_tabs')->set_current_page(2);
  $step = $builder->get_object('restore_tabs')->get_current_page()+1;
  set_subtitle($RESTORE_STEPS[$step-1]);
  if ($step == 1) {
    # Restore Step 1
    restore_source_changed();
    find_local_drives();
    set_partition_dropdown('restore_source_local');
    set_share_dropdown('restore_source_network');
    $builder->get_object('restore_button_next')->set_sensitive(TRUE);
  } elsif ($step == 2) {
    # Restore Step 2
    $builder->get_object('restore_button_next')->set_sensitive(FALSE);
    if ($builder->get_object('restore_source_use_local')->get_active()) {
      my ($type, $source) = split(/\|/, $builder->get_object('restore_source_local')->get_active_text());
      $status{'mount_type'} = $type;
      $status{'mount_source'} = $source;
    } else {
      my ($type, undef) = split(/\|/, $builder->get_object('restore_source_network')->get_active_text());
      $status{'mount_type'} = $type;
      $status{'mount_source'} = $builder->get_object('restore_source_server')->get_text();
      $status{'mount_user'} = $builder->get_object('restore_source_user')->get_text();
      $status{'mount_pass'} = $builder->get_object('restore_source_pass')->get_text();
      $status{'mount_domain'} = $builder->get_object('restore_source_domain')->get_text();
      $status{'mount_version'} = $builder->get_object('restore_source_version')->get_text();
    }
    my $mount_ok = 0;
    my $mount_cmd = "";
    my $mount_stderr_msg = "";
    ($mount_ok, $mount_cmd, $mount_stderr_msg) = &mount_data();
    if ($mount_ok==0) {
      my $failed_to_access_drive_msg =  loc("Could not access the source drive:\n\n%1", $mount_stderr_msg);
      # The error message printed by the mount command provides a more descriptive explanation about why the network mount failed
      # (eg, could not resolve address for XYZ), but is sometimes only available in English. Also network mounts configured by technical users
      # may be used by non-technical users.
      my $check_username_password_msg =  loc("Please ensure the username, password and other fields provided are correct, and try again.");
      my $internal_mount_cmd_msg =  loc("The mount command used internally was: `%1`", $mount_cmd);
      if (($status{'mount_type'} =~ /SMB/) or ($status{'mount_type'} =~ /FTP/)) {
        # Display error message for network mount type (SMB/CIFS, FTP)
        message_box("$failed_to_access_drive_msg\n\n$check_username_password_msg\n\n$internal_mount_cmd_msg");
      } else {
        # Display error message for directly connected hard drive
        message_box("$failed_to_access_drive_msg");
      }
      $step = $builder->get_object('restore_tabs')->set_current_page(0);
      set_subtitle($RESTORE_STEPS[0]);
    } else  {
      $builder->get_object('restore_file')->set_current_folder(MOUNT_POINT);
      $builder->get_object('restore_filefilter')->set_name('Backup Images');
      $builder->get_object('restore_filefilter')->add_pattern('*.backup');
    }
    $builder->get_object('restore_button_next')->set_sensitive(TRUE);
  } elsif ($step == 3) {
    # Restore Step 4
    set_drive_dropdown('restore_dest');
    $builder->get_object('restore_button_next')->set_sensitive(TRUE);
  } elsif ($step == 4) {
    # Restore Step 5
    $builder->get_object('restore_button_next')->hide();
    $builder->get_object('restore_progress')->set_sensitive(FALSE);
    refresh_window();
    do_restore();
    refresh_window();
    $builder->get_object('restore_button_cancel')->set_label(loc('Exit'));
  }
  refresh_window();
}

sub restore_scan_network {
  # Scan the network and add shares to list
  scan_network('restore_source_network');
}

sub restore_source_changed {
  # The source was changed (local/network)
  our $builder;
  my $local = $builder->get_object('restore_source_use_local')->get_active();
  if ($local!=1) {
    $builder->get_object('restore_frame_local')->hide();
    $builder->get_object('restore_frame_network')->show();
  } else {
    $builder->get_object('restore_frame_network')->hide();
    $builder->get_object('restore_frame_local')->show();
  }
  refresh_window();
}

sub restore_source_network_changed {
  # The network source was changed
  our $builder;
  my $share = $builder->get_object('restore_source_network')->get_active_text();
  if (defined($share)) {
    my ($type, $server) = split(/\|/, $share);
    my $server_editable = TRUE;
    my $domain_editable = TRUE;
    my $version_editable = TRUE;
    if ($server eq '') {
      if ($type eq 'FTP') {
        # It's a manually-entered FTP share
        $server = get_subnet();
        $server =~ s/\d+$//g;
      } else {
        # It's a manually-entered SMB share
        $server = default_share_name;
      }
    } else {
      # It's an automatically-found share
      $server =~ s/^smb:|^ftp:\/\///g;
      $server_editable = FALSE;
    }
    if ($type ne 'SMB') {
      $domain_editable = FALSE;
      $version_editable = FALSE;
    }
    $builder->get_object('restore_source_server')->set_text($server);
    $builder->get_object('restore_source_server')->set_sensitive($server_editable);
    $builder->get_object('restore_source_domain')->set_sensitive($domain_editable);
    $builder->get_object('restore_source_version')->set_sensitive($version_editable);
  }
}

sub restore_file_changed {
  # Make sure the restore file is valid
  our $builder;
  my $val = FALSE;
  my $restore_file = $builder->get_object('restore_file')->get_filename();
  if (!defined($restore_file)) { $restore_file = ''; }
  if ($restore_file ne '') {
    $val = TRUE;  
  } else {
    $val = FALSE;
  }
  $builder->get_object('restore_button_next')->set_sensitive($val);
}

sub do_restore {
  # Restore from the backup
  our $builder;
  our %status;
  our %drives;
  our $PROGRESS;
  set_status(loc("Preparing destination drive..."));
  $builder->get_object('restore_progress')->set_sensitive(TRUE);
  my $src = $builder->get_object('restore_file')->get_filename();
  my $dest_drive = $builder->get_object('restore_dest')->get_active_text();
  $src =~ s/\.backup$//g;
  my $src_mbr = $src.'.mbr';
  my $src_parts = $src.'.backup';
  my $src_size = $src.'.size';
  my $src_sfdisk = $src.'.sfdisk';
  # Warn if we are restoring to the source drive
  my $src_drive = $status{'mount_source'};
  print loc("Comparing %1 to %2...",$src_drive,$dest_drive)."\n";
  if ($src_drive eq $dest_drive) {
    my $response = 'no';
    if (allow_source_overwrite) {
      $response = get_confirmation(loc("Are you sure you want to restore the backup to the same drive the source image is located on? Unless you know what you are doing, this will result in loss of all data on the drive, including the backup image!"));
    } else {
      error_message("Not restoring to the source drive!");
    }
    if ($response ne 'yes') {
      on_main_app_destroy();
      die(loc("Aborting.")."\n");
    }
  }
  # Get sizes of original and destination drives in bytes
  my $quoted_src_size = shell_quote($src_size);
  my $src_bytes = `cat $quoted_src_size`;
  $src_bytes =~ s/\D//g;
  print "*** Size of original drive: $src_bytes bytes\n";
  my $quoted_src_sfdisk = shell_quote($src_sfdisk);
  my $src_fdisk_text = `cat $quoted_src_sfdisk`;
  # louvetch's popular unofficial Ubuntu 16.04 Redo Backup v1.0.4 update writes empty sfdisk file, so the restore logic needs to carefully
  # workaround this to preserve backwards compatibility (see https://github.com/rescuezilla/rescuezilla/issues/32 for more information)
  my $louvetch_extended_partition_skip = 0;
  my $is_empty_sfdisk = (("$src_fdisk_text" cmp "") == 0);
  if ($is_empty_sfdisk) {
    my $empty_sfdisk_bug_url = "https://github.com/rescuezilla/rescuezilla/wiki/Bugs-in-unofficial-Redo-Backup-updates#bugs-in-louvetchs-ubuntu-1604-releases";
    # Context for translators: The two popular unofficial updates of Redo Backup v1.0.4 by Sourceforge user louvetch have a major bug.
    # This major bug affected both the English language and French language versions of this unofficial update. All data can be restored with careful
    # manual intervention. Given the popularity of those unofficial updates, translating this error message is still important.
    my $empty_sfdisk_msg = loc("The backup's extended partition information is empty or missing. This happens with incomplete backups created by an unofficial Redo Backup update. If the backup contains extended partitions, these will not restore correctly. All data is still fully recoverable but manual intervention is required to fully restore the extended partitions. Please consult %1 for information and assistance. The destination drive has not yet been modified. Do you wish to continue with the restore?", $empty_sfdisk_bug_url);
    print "$empty_sfdisk_msg\n";
    my $response = get_confirmation($empty_sfdisk_msg);
    if ($response ne 'yes') {
      on_main_app_destroy();
      die("Aborting.\n");
    }
    $louvetch_extended_partition_skip = 1;
  } elsif ('sectors' eq fdisk_units($src_fdisk_text)) {
    # If sfdisk file is present, check whether the partition can be successfully restored.
    print "*** Reading original drive partition table.\n";
    # Get the byte offset of the end of the last partition listed in the backup
    my $src_bytes_fdisk = max(values(%{partends($src_fdisk_text)}));
    if ($src_bytes_fdisk > $src_bytes) {
      print "Warning: stored size of original drive $src_bytes is smaller than size calculated from original partition table $src_bytes_fdisk !\n";
    }
    $src_bytes = $src_bytes_fdisk;
    print "*** Size of original drive (from partition table): $src_bytes bytes\n";
    my $dest_bytes = `/sbin/blockdev --getsize64 '/dev/$dest_drive'`;
    $dest_bytes =~ s/\D//g;
    print "*** Size of destination drive: $dest_bytes bytes\n";
    if ($src_bytes > $dest_bytes) {
      my $diff_mb = int((($src_bytes - $dest_bytes) / 1024) / 1024);
      fatal_crash(loc("The drive you are attempting to restore to is %1 MB smaller than the original. You must restore to a drive that is the same size or larger than the original.",$diff_mb));
    }
  }
  # The open() function does not appear to be processed input through a shell, so no need to use shell_quote().
  open(INFILE, $src_parts) or fatal_crash(loc("Could not read from %1! Aborting.",$src_parts));
  my @partlist = <INFILE>;
  close INFILE;
  my $response = get_confirmation(loc("Are you sure you want to restore the backup to /dev/%1? Doing so will permanently overwrite the data on this drive!",$dest_drive));
  if ($response ne 'yes') {
    on_main_app_destroy();
    die("Aborting.\n");
  }
  umount_warn_on_busy("/mnt/$dest_drive?*");
  sleep(0.5);

  # Get filesize of MBR backup via stat array
  my $src_mbr_size = ((stat $src_mbr)[7]);
  # An old unofficial update of Redo Backup v1.0.4 changed backed up only 512 bytes from the start of the disk instead of 32,768 bytes. This means
  # the GRUB stage 1.5 boot loader may be lost for any user who has created a backup using that old, unofficial update and is restoring to a disk that
  # has since been erased. See the URL below for more information.
  if ($src_mbr_size==512)  {
    # Explain the situation to users with this issue and link to further information about how the GRUB boot loader can be regenerated, and confirm whether they wish to proceed.
    my $truncated_bootloader_bug_url = "https://github.com/rescuezilla/rescuezilla/wiki/Bugs-in-unofficial-Redo-Backup-updates#bugs-in-chcatzsfs-ubuntu-1310-and-1404-releases-german-language-only";

    # Context for translators: Two popular unofficial Redo Backup v1.0.4 updates by Sourceforge user chcatzsf have major bugs where bootloaders like GRUB are not not fully backed up, so Linux-based operating
    # cannot boot after a restore. This bug only affected those two updates (German-language only) and the problem can be fixed with careful manual intervention. Translating this message into languages other
    # than English and German is not required.
    # Full details in: https://github.com/rescuezilla/rescuezilla/wiki/Bugs-in-unofficial-Redo-Backup-updates#bugs-in-chcatzsfs-ubuntu-1310-and-1404-releases-german-language-only
    my $missing_bootloader_bytes_msg = loc("The backup's bootloader data is shorter than expected. This happens with backups created by an unofficial Redo Backup update. If the backup contained certain bootloaders like GRUB, the restored hard drive will not boot correctly without a manual fix. All data is still fully recoverable but manual intervention may required to restore the bootloader. Please consult %1 for information and assistance. The destination drive has not yet been modified. Do you wish to continue with the restore?",$truncated_bootloader_bug_url);
    my $response = get_confirmation($missing_bootloader_bytes_msg);
    if ($response ne 'yes') {
      on_main_app_destroy();
      die("Aborting.\n");
    }
  }
  print "*** ".loc("Writing MBR to %1",$dest_drive)."\n";
  set_status(loc("Writing master boot record to destination drive..."));
  my $quoted_src_mbr = shell_quote($src_mbr);
  # Restore MBR, primary GPT, and alignment gap (which on MBR systems is the post-MBR gap containing the GRUB2 core.img)
  system("dd if=$quoted_src_mbr of='/dev/$dest_drive' bs=512; sync;");
  sleep(0.5);  
  print "*** ".loc("Restoring partition table to %1",$dest_drive)."\n";
  set_status(loc("Writing extended partition table to destination drive..."));
  my $quoted_backup_version_file = shell_quote("/$src.rescuezilla.backup_version");
  my $backup_version = `cat $quoted_backup_version_file`;
  chomp($backup_version);
  print loc("Detected backup created with %1",$backup_version)."\n";
  my $restore_cmd = "";
  if ($is_empty_sfdisk) {
    # Handle restore for louvetch's unofficial Ubuntu 16.04 Redo Backup update (see https://github.com/rescuezilla/rescuezilla/issues/32)
    print "Skipping restoring partition table using sfdisk, as backup's partition information is empty or missing\n";
  } else {
    if (("$backup_version" cmp "") == 0) {
        my $memory_bus_width = `getconf LONG_BIT`;
        chomp($memory_bus_width);
        my $sfdisk_ver = "v2.20.1.${memory_bus_width}bit";
        print("No version number detected. Therefore backup assumed to be made by v1.0.4, so using $sfdisk_ver sfdisk.\n");
        # Using sfdisk version bundled with Redo Backup and Recovery v1.0.4, with the required arguments that have been removed from newer versions
        print("Using sfdisk $sfdisk_ver to restore the Redo Backup and Recovery v1.0.4 backup, for maximum compatibility\n");
        my $tool = "sfdisk.$sfdisk_ver";
        check_command("$tool --version");
        system("$tool -fx '/dev/$dest_drive' < $quoted_src_sfdisk; sync");
    } else {
        my $tool = "sfdisk";
        check_command("$tool --version");
        system("$tool -f '/dev/$dest_drive' < $quoted_src_sfdisk; sync");
    }
  }
  sleep(0.5);
  print "*** ".loc("Reloading partition table from %1",$dest_drive)."\n";
  set_status(loc("Reloading new partition table from destination drive..."));
  umount_warn_on_busy("/dev/$dest_drive?*");
  system("partprobe '/dev/$dest_drive'");
  sleep(1);
  $status{'start'} = time();
  $status{'part_list'} = \@partlist;
  $status{'last_part'} = $partlist[-1];
  $status{'total_parts'} = scalar(@partlist);
  $status{'current_part'} = 0;
  my $total_bytes = 0;
  # Verify all partitions now exist; crash otherwise
  foreach my $part (@{$status{'part_list'}}) {
    chomp($part);
    my ($src_base_device, $src_partition_number) = split_device_string($part);
    my $dest_partition_node = join_device_string($dest_drive, $src_partition_number);
    # FIXME: Update this misleading comment (including localizations if possible)
    print "*** ".loc("Verifying that /dev/%1 exists and can be restored to: ",$dest_partition_node);
    my $part_check = `file '/dev/$dest_partition_node' | grep 'block special' | wc -l`;
    if ($part_check==1) {
      print loc("OK")."\n";
      # Add the partition information to the global variables used to share state
      # TODO: Overhaul this application to remove use of global variables to share state.
      my $bytes = `cat '/sys/block/$dest_drive/$dest_partition_node/size'`;
      chomp($bytes);
      $bytes = abs(int($bytes*512));
      print "*** ".loc("Device %1 is %2 bytes...",$dest_partition_node,$bytes)."\n";
      # TODO: Indexing by source partition number (not dest). This is acceptable within current limitations
      # TODO: (immature partition-to-partition backup), but should be rectified in future.
      $drives{$dest_drive}{'parts'}{$src_partition_number}{'bytes'} = $bytes;
      $drives{$dest_drive}{'parts'}{$src_partition_number}{'size'} = format_size($bytes);
      $status{'total_bytes'} += $bytes;
    } else {
      print loc("FAIL")."\n";
      # A partition table that did not restore properly is a fatal error.
      # The only exception is when handling backwards compatibility for the Ubuntu 16.04-based unofficial Redo updates.
      if ($louvetch_extended_partition_skip == 0) {
        fatal_crash(loc("The partition table did not restore properly. The backup image may contain all your data, but without a valid partition table, no data can be restored."));
      } else {
        print "*** ".loc("The parititon table didn't restore properly but continuing with restore (louvetch extended partition)");
      }
    }
  }
  $status{'done_bytes'} = 0;
  print "*** ".loc("Restoring %1 total bytes of partitioned space.",$status{'total_bytes'})."\n";
  Glib::Timeout->add(50, \&update_restore_progress);
  refresh_window();
}

sub update_restore_progress {
  # Update the restore progress bar
  our $PROGRESS;
  our %drives;
  our %status;
  our $builder;
  my $progress_bar = $builder->get_object('restore_progress');
  my $data = undef;
  our $i;
  my $part = $status{'part_list'}[$status{'current_part'}];
  chomp($part);
  my $src = $builder->get_object('restore_file')->get_filename();
  my $enduser_drive_string = $src;
  my ($base_device, $partition_number) = split_device_string($part);
  my $dest_drive = $builder->get_object('restore_dest')->get_active_text();
  # Combine the target drive with the current partition number in an NVMe-aware manner.
  my $dest_partition_node = join_device_string($dest_drive, $partition_number);
  $src =~ s/\.backup$//g;
  my $src_mbr = $src.'.mbr';
  # See if the filehandle is open
  if (!defined($PROGRESS)) {
    umount_warn_on_busy("/dev/$dest_partition_node");
    system("dd if=/dev/zero of='/dev/$dest_partition_node' bs=1K count=1000; sync");
    set_status(loc("Preparing to restore backup for Drive %1, Part %2...",$enduser_drive_string,$partition_number));
    my $quoted_backup_version_file = shell_quote("/$src.rescuezilla.backup_version");
    my $backup_version = `cat $quoted_backup_version_file`;
    chomp($backup_version);
    print loc("Detected backup created with %1",$backup_version)."\n";
    my $restore_cmd = "";
    my $quoted_src_partition_prefix = shell_quote("/${src}_part${partition_number}");
    if (("$backup_version" cmp "") == 0) {
        my $memory_bus_width = `getconf LONG_BIT`;
        chomp($memory_bus_width);
        my $partclone_ver = "v0.2.43.${memory_bus_width}bit";
        print("No version number detected. Therefore backup assumed to be made by v1.0.4, so using $partclone_ver partclone.restore.\n");
        # The Redo Backup v1.0.4 partclone version uses different restore syntax, and autodetects raw formats differently
        print("Using partclone $partclone_ver to restore the Redo Backup and Recovery v1.0.4 backup, for maximum compatibility\n");
        my $tool = "partclone.restore.$partclone_ver";
        check_command("$tool --version");
        print "*** ".loc("Processing %1 using %2...",$dest_partition_node,$tool)."\n";
        $restore_cmd = "( cat $quoted_src_partition_prefix.* | pigz -d -c | $tool -F -L /partclone.log -O '/dev/$dest_partition_node' ) 2>&1 |";
    } else {
        print loc("Restoring backup created with version: %1",$backup_version)."\n";
        # Assuming backup was created with a format compatible with the 1.0.5 release.
        # TODO: Compare the MAJOR.MINOR.PATCH components that make up the version number to automatically handle newer versions
        # TODO: when the backup format and partclone syntax have not changed.
        my $quoted_partition_partclone_command_file = shell_quote("$src.partclone.command.part$partition_number");
        my $tool = `cat $quoted_partition_partclone_command_file`;
        chomp($tool);
        check_command("$tool --version");
        print "*** ".loc("Processing %1 using %2...",$dest_partition_node,$tool)."\n";
        $restore_cmd = "( cat $quoted_src_partition_prefix.* | pigz -d -c | $tool --restore -F -L /partclone.log -O '/dev/$dest_partition_node' ) 2>&1 |";
    }
    print "*** ".loc("Executing: ")."$restore_cmd\n";
    open $PROGRESS, "$restore_cmd";
    sleep(0.5);
    return TRUE;
  } else {
    # Read available data and append it to $status{'command_output'} until a newline is reached
    my $char = '';
    do {
      $char = getc($PROGRESS);
      if (!defined($char)) {
        return 1;
      } else {
        if (($char eq "\n") || ($char eq "\r") || (ord($char)==27)) {
          undef($char);
        } else {
          $status{'command_output'} .= $char;
        }
      }
    } while (defined($char));
  }
  # Try to read command progress and append it to the data
  $data = $status{'command_output'};
  undef($status{'command_output'});
  if (defined($data)) {
    # Remove newlines and lines that are all spaces
    $data =~ s/\n|\r|\[A|^\s+$//g;
    refresh_window();
    $i++;
    # Split it up and show the results    
    if ($data =~ m/Starting to/) {
      # Starting a filesystem
      my (undef, $current_part) = split(/\(\/dev\//, $data);
      $current_part =~ s/\).*$//g;
      $status{'current_part_device'} = $current_part;
      print ">>> ".loc("Starting to restore %1",$status{'current_part_device'})."\n";
      print ">>> ".loc("List of partitions:")."\n";
      foreach my $item (@{$status{'part_list'}}) {
        $msg = '';
        if ($item eq $current_part) { $msg = loc("(Processing)"); }
        print "\t* $item $msg\n";
      }
    } elsif ($data =~ m/Device size: /) {
      # Device size reported
      my (undef, $dev_size) = split(/: /, $data);
      $dev_size =~ s/^\s+|\s+$//g;
      print(">>> ".loc("Device size: %1",$dev_size)."\n");
    } elsif ($data =~ m/Space in use: /) {
      # Device used space reported
      my (undef, $dev_used) = split(/: /, $data);
      $dev_used =~ s/^\s+|\s+$//g;
      print(">>> ".loc("Space in use: %1",$dev_used)."\n");
    } elsif ($data =~ m/^.*\.c.*: /) {
      # A warning was encountered
      my (undef, $warning) = split(/: /, $data);
      print(">>> ".loc("Warning: ")."$warning\n");
      set_status(loc("Warning: ")."$warning");
    } elsif ($data =~ m/Reading Super Block/) {
      print(">>> ".loc("Reading super block:")."\n");
      set_status(loc("Reading super block for Drive %1, Part %2...",$enduser_drive_string,$partition_number));
    } elsif ($data =~ m/Calculating bitmap/) {
      print(">>> ".loc("Calculating bitmap")."\n");
      set_status(loc("Calculating bitmap for Drive %1, Part %2...",$enduser_drive_string,$partition_number));
    } elsif ($data =~ m/Elapsed.+,$/) {
      # Restore progress line
      my $elapsed = substr($data,9,8);
      my $remaining = substr($data,30,8);
      my $pct = substr($data,51,6);
      my $rate = substr($data,60,12);
      $pct =~ s/\s+//g;
      $rate =~ s/\s+//g;
      print ">>> ".loc("(RESTORE) Elapsed: *%1* | Remaining: *%2* | Percent: *%3* | Speed: *%4*",$elapsed,$remaining,$pct,$rate)."\n";
      $msg = loc("Part %1 of %2 (%3%) %4 Elapsed %5 Remaining",$status{'current_part'}+1,$status{'total_parts'},$pct,$elapsed,$remaining);
      $builder->get_object('restore_progress_status')->set_text($msg);
      # Base overall percentage on number of total bytes
      my $current_bytes = int(($pct/100) * $drives{$dest_drive}{'parts'}{$partition_number}{'bytes'}) + $status{'done_bytes'};
      my $overall_pct = ($current_bytes / $status{'total_bytes'}) + (($pct / 100) / $status{'total_bytes'});
      if ($overall_pct > 1) { $overall_pct = 1; }
      set_status(loc("Restoring part %1 (%2) at %3",$status{'current_part'}+1,$drives{$dest_drive}{'parts'}{$partition_number}{'size'},$rate));
      print ">>> ".loc("Drive: %1 | Partition: %2 | Current bytes: %3 | Overall: %4",$src,$partition_number,$current_bytes,$overall_pct)."\n";
      $progress_bar->set_fraction($overall_pct);
      $msg = loc("%1% Complete", sprintf("%.2f", $overall_pct * 100));
      $progress_bar->set_text($msg);
    } elsif ($data =~ m/not_used.+/) {
      # Bitmap reading progress line, no longer appears to be reported
      # Elapsed: 00:00:02, Remaining: 00:02:25, Completed:   1.36%,   1.83GB/min,
      my $elapsed = substr($data,9,8);
      my $remaining = substr($data,30,8);
      my $pct = substr($data,51,6);
      $pct =~ s/\s+//g;
      print ">>> ".loc("(BITMAP) Elapsed: *%1* | Remaining: *%2* | Percent: *%3*",$elapsed,$remaining,$pct)."\n";
      $msg = loc("Reading bitmap for part %1 of %2",$status{'current_part'}+1,$status{'total_parts'});
      $builder->get_object('restore_progress_status')->set_text($msg);
      set_status(loc("Reading bitmap for Drive %1, Part %2 (%3% done, %4 remaining)",$enduser_drive_string,$partition_number,$pct,$remaining));
    } elsif ($data =~ m/Cloned successfully/) {
      set_status(loc("Partition completed."));
      print ">>> ".loc("Partition %1 completed.",$status{'current_part_device'})."\n";
      print "\t".loc("Current part: %1",$status{'current_part'}+1)."\n";
      print "\t".loc("Total parts: %1",$status{'total_parts'})."\n";
      if ($status{'current_part'}==$status{'total_parts'}-1 ) {
        $builder->get_object('restore_progress_status')->set_text('');
        $progress_bar->set_fraction(1);
        set_status(loc("Operation completed successfully."));
        my @lines = split(/\n/, $data);
        my $start = FALSE;
        $builder->get_object('restore_button_cancel')->set_label(loc("Exit"));
        refresh_window();
        # Unmount stuff
        system("sync");
        sleep(0.5);
        print "*** ".loc("Writing MBR to %1",$dest_drive)."\n";
        set_status(loc("Rewriting master boot record to destination drive..."));
        my $quoted_src_mbr = shell_quote($src_mbr);
        system("dd of=/dev/$dest_drive if=$quoted_src_mbr bs=32768 count=1; sync;");
        sleep(0.5);
        my $elapsed = sprintf("%.1f", (time()-$status{'start'})/60);
        print ">>> ".loc("Operation complete.")."\n";
        set_status(loc("Restore complete."));
        beeper('done');
        message_box(loc("Backup restored in %1 minutes.",$elapsed));
        $msg = loc("Backup restored successfully.");
        system("notify-send -i ".APP_ICON." '${msg}'");
        umount_warn_on_busy(MOUNT_POINT);
        return 0;
      } else {
        close $PROGRESS;
        undef($PROGRESS);
        # Need to add the size of the partition to the total bytes completed
        $status{'done_bytes'} += $drives{$dest_drive}{'parts'}{$partition_number}{'bytes'};
        print ">>> ".loc("Backed up %1 of %2 total bytes.",$status{'done_bytes'},$status{'total_bytes'})."\n";
        $status{'current_part'}++;
        print loc("Advancing to next partition.")."\n";
        return TRUE;
      }
    } else {
      if (length($data)>0) {
        print "$data\n";
        if ($data =~ m/error|warning/i) {
          error_message($data);
        }
      }
    }
  }
  return TRUE;   
}


##### Form Logic #######################################################
sub get_confirmation {
  # Get confirmation from a yes/no dialog
  our $builder;
  my $question = loc("Are you sure?");
  if (defined($_[0])) { $question = $_[0]; }
  my $dialog = Gtk2::MessageDialog->new($builder->get_object('main_app'),
    'destroy-with-parent',
    'warning', # message type
    'yes-no', # which set of buttons?
    $question);
  my $response = $dialog->run;
  $dialog->destroy;
  return $response;
}

sub get_retry_confirmation {
  # Get user response to potentially fatal error
  our $builder;
  my $question = loc("Are you sure?");
  if (defined($_[0])) { $question = $_[0]; }
  my $dialog = Gtk2::MessageDialog->new($builder->get_object('main_app'),
    'destroy-with-parent',
    'warning', # message type
    'ok-cancel', # which set of buttons?
    $question);
  my $response = $dialog->run;
  $dialog->destroy;
  return $response;
}

sub next_tab {
  # Show the next tab of a Backup or Restore procedure
  our $builder;
  my $current_tab = $builder->get_object('main_tabs')->get_current_page();
  if ($current_tab==1) {
    # Backup mode
    $builder->get_object('backup_tabs')->next_page();
    my $backup_tab = $builder->get_object('backup_tabs')->get_current_page();
    backup_step($backup_tab+1);
  } elsif ($current_tab==2) {
    # Restore mode
    $builder->get_object('restore_tabs')->next_page();
    my $restore_tab = $builder->get_object('restore_tabs')->get_current_page();
    restore_step($restore_tab+1);
  } elsif ($current_tab==3) {
    # USB Installer mode
    $builder->get_object('usb_tabs')->next_page();
    my $usb_tab = $builder->get_object('usb_tabs')->get_current_page();
    usb_step($usb_tab+1);
  }
}

sub set_main_title {
  # Set the main title
  my $title = $_[0];
  our $builder->get_object('main_title')->set_text($title);
}

sub set_subtitle {
  # Set the subtitle, which is a description of the current step
  my $subtitle = $_[0];
  our $builder->get_object('main_subtitle')->set_text($subtitle);
}

sub set_cursor {
  # Set the mouse pointer cursor
  my $cursor = $_[0];
  our $builder->get_object('main_app')->window()->set_cursor(Gtk2::Gdk::Cursor->new($cursor));
}

sub set_status {
  # Set the status message at the bottom of the window
  my $status = $_[0];
  my $ready_msg = loc("Ready");
  if (!defined($status)) { $status = $ready_msg; }
  our $builder->get_object('main_statusbar')->push(0, $status);
  refresh_window();
}

sub set_busy {
  # Disable the application to indicate that we are busy working
  if ($_[0] ne '') {
    set_cursor("watch");
    set_status($_[0]);
    our $builder->get_object('main_app')->set_sensitive(FALSE);
    show_busy_bar($_[0]);
  } else {
    set_cursor("arrow");
    set_status(loc("Done."));
    our $builder->get_object('main_app')->set_sensitive(TRUE);
    our $busy_bar->destroy();
  }
  refresh_window();
}

sub show_busy_bar {
  # Show a pulsing progress bar
  my $message = $_[0];
  if (!defined($message)) { $message = loc("Please wait..."); }
  my $parent = our $builder->get_object('main_app');
  our $busy_bar = Gtk2::Dialog->new(loc('Please wait...'), $parent,
    'destroy-with-parent',
    'gtk-cancel' => 'none'
  );
  my $pgb = Gtk2::ProgressBar->new();
  $pgb->set_text($message);
  my $abox = Gtk2::Alignment->new(.50, .50, 1, 1);
  $abox->set_padding(30, 30, 30, 30);
  $busy_bar->vbox->add($abox);
  $abox->add($pgb);
  $busy_bar->signal_connect(response => sub { $_[0]->destroy });
  $busy_bar->show_all;
  $busy_bar->window()->set_cursor(Gtk2::Gdk::Cursor->new('watch'));
  Glib::Timeout->add(100, \&update_busy_bar, $pgb);
}

sub update_busy_bar {
  # Update the pulsing progress bar
  my ($progress_bar) = @_;
  $progress_bar->pulse;
  return TRUE;
}

sub refresh_window {
  # Refresh the application window
  while (Gtk2->events_pending()) { Gtk2->main_iteration(); }
}

sub fatal_crash {
  # Crash out with a fatal error message
  my $parent = our $builder->get_object('main_app');
  my $message = $_[0].chr(13).chr(13).loc("Unable to continue. The program will now exit.");
  my $dialog = Gtk2::MessageDialog->new($parent, 'modal', 'error', 'cancel', $message);
  beeper('warning');
  $dialog->run;
  $dialog->destroy;
  on_main_app_destroy();
  my $fatal_error = loc("Fatal Error:");
  die("$fatal_error $message\n");
}

sub error_message {
  # Show a non-fatal error message
  my $parent = our $builder->get_object('main_app');
  my $message = $_[0];
  my $dialog = Gtk2::MessageDialog->new($parent, 'modal', 'warning', 'ok', $message);
  beeper('error');
  $dialog->run;
  $dialog->destroy;
}

sub message_box {
  # Show an informational message
  my $parent = our $builder->get_object('main_app');
  my $message = $_[0];
  my $dialog = Gtk2::MessageDialog->new($parent, 'modal', 'info', 'ok', $message);
  $dialog->run;
  $dialog->destroy;
}

sub on_main_app_destroy {
  # Close the application and all backup binaries
  my $bins = `find /usr/sbin/ -type f -name 'partclone.*' -printf '%f\n'`;
  my @bins = split(/\n/, $bins);
  foreach (@bins) {
    system('( killall -9 $_ 2>&1 ) > /dev/null');
  }
  our $PROGRESS;
  if (defined($PROGRESS)) { close($PROGRESS); }
  Gtk2->main_quit();
}


##### Core program functions ###########################################
sub save_file {
  # Save a string to the specified file
  my $data = $_[0];
  my $outfile = $_[1];
  my $failed_to_open_file = loc("Could not open %1 for writing!",$outfile);
  # The open() function does not appear to be processed input through a shell, so no need to use shell_quote().
  open(OUT, ">$outfile") or fatal_crash($failed_to_open_file);
  print OUT $data;
  close OUT;
}

sub which_backup_tool {
  # Determine which backup tool to call based on the FS type
  my $fs = $_[0];
  my $tool = "partclone.";
  my $args = " -c ";
  if ($fs =~ m/btrfs/) {
    $tool .= "btrfs";
  } elsif ($fs =~ m/exfat/) {
    $tool .= "exfat";
  } elsif ($fs =~ m/ext/) {
    $tool .= "extfs";
  } elsif ($fs =~ m/f2fs/) {
    $tool .= "f2fs";
  } elsif ($fs =~ m/fat/) {
    $tool .= "fat";
  } elsif ($fs =~ m/hfsplus/) {
    $tool .= "hfsp";
  } elsif ($fs =~ m/ntfs/) {
    $tool .= "ntfs";
  } elsif ($fs =~ m/reiser4/) {
    $tool .= "reiser4";
  } elsif ($fs =~ m/xfs/) {
    $tool .= "xfs";
  } else {
    $tool .= "dd";
    $args = "";
  }
  return ($tool, $args);
}

sub mount_data {
  # Mounts the specified local disk, SMB/CIFS server or FTP server
  # TODO: Overhaul this application to remove use of global variables to share state. (https://github.com/rescuezilla/rescuezilla/issues/49)
  # Returns: mount status, the mount command which was used last, and the stderr string of that command.

  # Mount the data device that backup images are stored on
  our %shares;
  our %status;
  system("mkdir -p ".MOUNT_POINT);
  umount_warn_on_busy(MOUNT_POINT);
  our $builder;

  my $mount_cmd = "";
  my $mount_stdout = "";
  my $mount_stderr = "";
  my $mount_retcode = 0;
  for ($status{'mount_type'}) {
    if (/DEV/) {
      # Mount a regular drive
      $status{'mount_source'} =~ s/\|//g;
      my $quoted_mount_source = shell_quote("/dev/$status{'mount_source'}");
      $mount_cmd = "mount $quoted_mount_source ".MOUNT_POINT;
      print "* ".loc("Executing: ")."$mount_cmd\n";
      ($mount_stdout, $mount_stderr, $mount_retcode) = capture { system($mount_cmd); };
      print("mount command stdout: $mount_stdout\nmount command stderr: $mount_stderr\n");
      if ($mount_retcode != 0) {
       my $mount;
       my $mp = MOUNT_POINT;
       $mount = `grep ^\Q/dev/$status{'mount_source'}\E /proc/mounts`;
       chomp $mount;
       $mount = (split( / /, $mount))[1];
       if ($mount) {
         $quoted_mount_source = shell_quote($mount);
         $mount_cmd = "mount $quoted_mount_source ".MOUNT_POINT;
         print "* ".loc("Executing: ")."$mount_cmd\n";
         ($mount_stdout, $mount_stderr, $mount_retcode) = capture { system($mount_cmd); };
         print("stdout: $mount_stdout\nstderr: $mount_stderr\n");
       }
      }
    } elsif (/SMB/) {
      # Mount a network share
      my $smb_args;

      # Write CIFS/SMB username/password credentials to a tmp file, so it does not get logged.
      my @smb_credential_args = ();
      if ($status{'mount_user'} ne '') { push(@smb_credential_args, "username=".$status{'mount_user'}); }
      if ($status{'mount_pass'} ne '') { push(@smb_credential_args, "password=".$status{'mount_pass'}); }
      my $cred = join("\n", @smb_credential_args);
      my $credential_tmp_file = '';
      if ($cred eq '') {
        $smb_args = "guest";
      } else {
        $credential_tmp_file = `mktemp`;
        chomp($credential_tmp_file);
        open(my $tmpfd, '>', $credential_tmp_file);
        print $tmpfd "$cred\n";
        close($tmpfd);
        $smb_args = "credentials='$credential_tmp_file'";
        # If the user does not supply password mount would try to prompt for
        # one locking up the application unless guest is specified.
        if ($status{'mount_pass'} eq '') { $smb_args = "$smb_args,guest"; }
      }
      if ($status{'mount_domain'} ne '') { $smb_args = "$smb_args,domain=".$status{'mount_domain'}; }
      if ($status{'mount_version'} ne '') { $smb_args = "$smb_args,vers=".$status{'mount_version'}; }
      my $quoted_mount_source = shell_quote($status{'mount_source'});
      $mount_cmd = "mount.cifs $quoted_mount_source ".MOUNT_POINT." -o $smb_args";
      print "* ".loc("Executing: ").$mount_cmd."\n";
      ($mount_stdout, $mount_stderr, $mount_retcode) = capture { system($mount_cmd); };
      print("stdout: $mount_stdout\nstderr: $mount_stderr\n");
      if ($credential_tmp_file ne '') { system(("shred", "-u",  $credential_tmp_file));}
    } elsif (/FTP/) {
      # Mount an FTP server
      my $ftpargs = '';
      if ($status{'mount_user'} ne '') { $ftpargs = "-o user='".$status{'mount_user'}."'"; }
      if ($status{'mount_pass'} ne '') { $ftpargs .= ":'".$status{'mount_pass'}."'"; }
      my $quoted_mount_source = shell_quote($status{'mount_source'});
      # FTP mount command without username/password
      $mount_cmd = "curlftpfs $quoted_mount_source ".MOUNT_POINT;
      ($mount_stdout, $mount_stderr) = capture { system($mount_cmd." $ftpargs"); };
      print("stdout: $mount_stdout\nstderr: $mount_stderr\n");
      print "* ".loc("Executing: ")."$mount_cmd <username/password arguments redacted> \n";
    } else {
      fatal_crash(loc("The device type '%1' is not valid.  Did you forget to select a backup location?",$status{'mount_type'}));
    }
  }
  my $mp = MOUNT_POINT;
  my $mounted = `mount | grep '$mp' | wc -l`;
  return ($mounted, $mount_cmd, $mount_stderr);
}

sub umount_partition {
  # Attempts to unmount a partition and returns whether the partition is still mounted.
  # Checking whether the drive is still mounted is required because both umount'ing an
  # already unmounted drive, and umount'ing a busy drive return the exit code 32,
  # which means "mount failure". The `findmnt` application is a portable way to
  # delineate this two situations.
  #
  # Input arguments:
  #   0, mount_point: The device node (or "/dev/sda") or mount point ("/mnt/test_path").
  #                   Note: Wildcards and asterisks *are* supported.
  #
  # Returns:
  #   list of partitions which are still mounted. Success if length 0.

  my $mount_point = $_[0];

  my $quoted_mount_point = shell_quote($mount_point);
  # Attempt to unmount the mount point.
  system("umount $quoted_mount_point 2>&1");

  # Use findmnt to robustly check whether the provided path (which may contain wildcard
  # characters) is mounted on Linux.
  my @partition_list = glob("$mount_point");
  my @still_mounted = ();
  foreach my $partition (@partition_list) {
    # Extract the "/dev/..." device node string from the input (which may be a mount point)
    my $device_node = `findmnt --raw --noheadings --output SOURCE \'$partition\'`;
    chomp($device_node);
    if ($device_node ne '') {
      push @still_mounted, $device_node;
    }
  }
  return @still_mounted;
} 

sub umount_warn_on_busy {
  # Unmounts a partition. If the partition is busy, it will warn the user and
  # allow the user to either fix the problem or abort the application.
  #
  # Input arguments:
  #   0, mount_point: The device node (or "/dev/sda") or mount point ("/mnt/test_path").
  #                   Note: Wildcards and asterisks *are* supported.

  my $mount_point = $_[0];
  # Keep looping until the busy partition list is empty
  my @busy_device_node_list = umount_partition("$mount_point");
  while (scalar(@busy_device_node_list) != 0) {
    my $partition_pretty_string = "";
    foreach my $device_node (@busy_device_node_list) {
      # Retrieve the device node and mount path (caller could have provided either)
      my $mount_path = `findmnt --raw --noheadings --output TARGET \'$device_node\'`;
      chomp($mount_path);
      $partition_pretty_string = $partition_pretty_string.$device_node.": ${mount_path}\n";
      print loc("Unable to unmount partition: %1", $partition_pretty_string)."\n";
    }
    my $partition_busy_msg = loc("Partition(s) were unable to be unmounted. Please close any applications using the following partition(s) and click OK.");
    # Append the busy partition information onto the localized string because localization framework not handling newlines well.
    # Not an ideal solution as localization should generally have access to the variable references, but works fine.
    $partition_busy_msg = "$partition_busy_msg\n\n$partition_pretty_string";
    my $response = get_retry_confirmation($partition_busy_msg);
    if ($response eq 'cancel') {
      $response = get_confirmation(loc("Are you sure you want to exit?"));
      if ($response eq 'yes') {
        on_main_app_destroy();
        die(loc("Aborting.")."\n");
      }
    }
    @busy_device_node_list = umount_partition("$mount_point");
  }
}

sub set_usb_dropdown {
  # Get all physical drives that are USB drives
  set_drive_dropdown('usb_dest', 'usb');
}

sub set_drive_dropdown {
  # Get all physical drives
  set_busy(loc("Getting list of drives..."));
  our %drives;
  if (keys(%drives)==0) { fatal_crash(loc("Could not locate any drives attached to your computer.")); }
  my $cbo = our $builder->get_object($_[0]);
  my $mdl = $cbo->get_model();
  $mdl->clear();
  my ($dev, $desc) = '';
  # Iterate over the drives hashmap using the generated drive number (rather than the device node), by
  # retrieving a numerical ordered array of the hashmap's keys.
  foreach my $drive (sort { $drives{$a}{'enduser_drive_number'} <=> $drives{$b}{'enduser_drive_number'} } keys %drives) {
    $dev = $drives{$drive}{'device'};
    $desc = $drives{$drive}{'desc'};
    if (length($desc)>MAX_WIDTH+3) { $desc = substr($desc,0,MAX_WIDTH).'...'; }
    if ((defined($_[1])) && ($_[1] eq 'usb')) {
      if ($drives{$drive}{'type'} eq 'usb') {
        $mdl->set($mdl->append, 0, $dev, 1, $desc);
      }
    } else {
      $mdl->set($mdl->append, 0, $dev, 1, $desc);
    }
  }
  my $num_drives = $mdl->iter_n_children();
  if ($num_drives==0) { fatal_crash(loc("No drives available.")); }
  $cbo->set_active(0);
  set_busy(FALSE);
}

sub set_partition_dropdown {
  # Populate the partition list for the given combobox
  our %drives;
  if (keys(%drives)==0) { fatal_crash(loc("Could not locate any partitions on your computer.")); }
  my $stage = '';
  my @blacklist = ();
  if ($_[0] =~ m/backup/) {
    # We're backing up
    $stage = 'backup';
    @blacklist = get_selected_partitions('backup_partitions');
  } elsif ($_[0] =~ m/restore/) {
    # We're restoring
    $stage = 'restore';
  }
  my $cbo = our $builder->get_object($_[0]);
  my $mdl = $cbo->get_model();
  $mdl->clear();
  # Iterate over the drives hashmap using the generated drive number (rather than the device node), by
  # retrieving a numerical ordered array of the hashmap's keys.
  foreach my $drive (sort { $drives{$a}{'enduser_drive_number'} <=> $drives{$b}{'enduser_drive_number'} } keys %drives) {
    # Iterate over the partitions of a particular drive by sorting the partition number using numerical (not lexical) ordering.
    foreach my $data (sort {$drives{$drive}{'parts'}{$a}{'partition_number'} <=> $drives{$drive}{'parts'}{$b}{'partition_number'}} keys %{ $drives{$drive}{'parts'} }) {
      my $num_parts = keys(%{ $drives{$drive}{'parts'} });
      my $enduser_drive_number = $drives{$drive}{'enduser_drive_number'};
      my $part = $drives{$drive}{'parts'}{$data}{'partition'};
      my $partition_number = $drives{$drive}{'parts'}{$data}{'partition_number'};
      my $fs = $drives{$drive}{'parts'}{$data}{'fstype'};
      my $label = $drives{$drive}{'parts'}{$data}{'label'};
      my $size = $drives{$drive}{'parts'}{$data}{'size'};
      if (!defined($size)) { $size = "Unknown size"; }
      my $os = $drives{$drive}{'parts'}{$data}{'os'};
      my $part_desc =  loc("Drive %1",$enduser_drive_number);
      if ($num_parts > 1) { $part_desc .= loc(", Part %1",$partition_number); }
      $part_desc .= ": ($size $fs)";
      if ($os ne '') { $part_desc .= " $os"; }
      if ($label ne '') { $part_desc .= " $label"; }
      if (grep $_ eq $part, @blacklist) {
        print "*** ".loc("Omitting backup source %1 from destination list",$part)."\n";
      } else {
        if (length($part_desc)>MAX_WIDTH+3) { $part_desc = substr($part_desc,0,MAX_WIDTH).'...'; }
        $mdl->set($mdl->append, 0, "DEV|$part", 1, $part_desc);
      }
    }
  }
  $cbo->set_active(0);
}

sub set_share_dropdown {  
  # Add the share list to the given combobox
  our %shares;
  my $cbo = our $builder->get_object($_[0]);
  my $mdl = $cbo->get_model();
  $mdl->clear();
  for my $share (sort keys %shares) {
    my $ip = $shares{$share}{'ip'};
    my $host = $shares{$share}{'host'};
    my $folder = $shares{$share}{'folder'};
    my $desc = $shares{$share}{'desc'};
    my $type = $shares{$share}{'type'};
    if (!defined($host)) { $host = $ip; }
    my $share_desc = '';
    if ($type eq 'FTP') {
      $share_desc = loc("FTP server \U%1",$host);
    } elsif ($type eq 'SMB') {
      $share_desc = loc("Shared folder %1 on %2",$folder,$host);
    }
    if ((defined($desc))&&($desc ne '')) { $share_desc .= " ($desc)"; }
    if (length($share_desc)>MAX_WIDTH+3) { $share_desc = substr($share_desc,0,MAX_WIDTH).'...'; }
    $mdl->set($mdl->append, 0, "$type|$share", 1, $share_desc);
  }
  $mdl->set($mdl->append, 0, "SMB|", 1, loc("Shared folder specified below"));
  $mdl->set($mdl->append, 0, "FTP|", 1, loc("FTP server specified below"));  
  $cbo->set_active(0);
}

sub get_selected_partitions {
  # Return the partitions that have been selected from a list
  my @selected = ();
  my $tv = our $builder->get_object($_[0]);
  my $mdl = $tv->get_model();
  my $total = $mdl->iter_n_children();
  for (my $i=0; $i<$total; $i++) {
    my $iter = $mdl->get_iter_from_string("$i");
    my ($part, $on) = $mdl->get($iter, 0, 1);
    if ($on) { push(@selected, $part); }
  }
  return @selected;
}

sub set_partition_list {
  # Set the list of partitions with checkboxes
  our %drives;
  if (keys(%drives)==0) { fatal_crash(loc('Could not locate any partitions on your computer.')); }
  my $tv = our $builder->get_object($_[0]);
  my $part_heading = loc("Part");
  my $save_heading = loc("Save");
  my $desc_heading = loc("Description");
  my $slist = Gtk2::SimpleList->new_from_treeview(
    $tv,
    $part_heading    => 'text',
    $save_heading    => 'bool',
    $desc_heading    => 'text',
  );
  my $tv_col = $tv->get_column(0);
  $tv_col->set_visible(FALSE);
  @{$slist->{data}} = (
    #[ TRUE, "sda2", "Drive 1, Part 1: (80GB) Windows XP Pro" ],
  );
  print loc("Obtaining partitions for drives...")."\n";
  for my $drive (sort keys %drives) {
    for my $data (sort keys %{ $drives{$drive}{'parts'} }) {
      my $num_parts = keys(%{ $drives{$drive}{'parts'} });
      my $enduser_drive_number = $drives{$drive}{'enduser_drive_number'};
      my $part = $drives{$drive}{'parts'}{$data}{'partition'};
      my $partition_number = $drives{$drive}{'parts'}{$data}{'partition_number'};
      my $fs = $drives{$drive}{'parts'}{$data}{'fstype'};
      my $label = $drives{$drive}{'parts'}{$data}{'label'};
      my $size = $drives{$drive}{'parts'}{$data}{'size'};
      if (!defined($size)) { $size = loc("Unknown size"); }
      my $os = $drives{$drive}{'parts'}{$data}{'os'};
      # FIXME: Unclear why this l10n string lookup doesn't work with this string,
      # FIXME: but works with other strings.
      # FIXME: May be bug with maketext deduplication?
      my $part_desc = loc("Drive %1, Part %2",$enduser_drive_number,$partition_number);
      $part_desc .= ": ($size $fs)";
      if ($os ne '') { $part_desc .= " $os"; }
      if ($label ne '') { $part_desc .= ", $label"; }
      if ($drive eq $_[1]) {
        push @{$slist->{data}}, [ $part, TRUE, $part_desc ];
      }
    }
  }
  #$slist->get_selection->set_mode('multiple');
  $slist->get_selection->unselect_all();
}

sub print_drive_list {
  # Print the drive list to the console
  our %drives;
  for my $dev (sort keys %drives) {
    print "*** $dev ***\n";
    for my $drive_key (sort keys %{ $drives{$dev} }) {
      print "\t$drive_key = $drives{$dev}{$drive_key}\n";
      if(ref($drives{$dev}{$drive_key}) eq 'HASH') {
        for my $partition_number (sort keys %{ $drives{$dev}{$drive_key} }) {
          print "\t".loc("Part %1",$partition_number).":\n";
          for my $pk (sort keys %{ $drives{$dev}{$drive_key}{$partition_number} }) {
            print "\t\t$pk = $drives{$dev}{$drive_key}{$partition_number}{$pk}\n";
          }
        }
      }
    }
    print "\n";
  }
}

sub print_share_list {
  # Print the share list to the console
  our %shares;
  for my $share (sort keys %shares) {
    print "*** $share ***\n";
    for my $share_key (sort keys %{ $shares{$share} }) {
      print "\t$share_key = $shares{$share}{$share_key}\n";
    }
    print "\n";
  }
}

sub find_local_drives {
  # Set the list of local drives, (only SCSI and USB drives)
  our %drives;
  my $drivelist = `fsarchiver probe 2>&1`;
  # For debug purposes, print the fsarchiver probe output.
  # TODO: Overhaul text processing to with clear, unit tested functions
  print("fsarchiver probe output:\n$drivelist\n");
  chomp($drivelist);
  if ($drivelist eq "") {
    return FALSE;
  } else {
    # Create an array of drives
    $drivelist =~ s/\n\[\=+DEVICE.*//s;
    $drivelist =~ s/\[\=+DISK.*\n//g;
    $drivelist =~ s/^\[|\]$//mg;
    my @list = split(/\n/, $drivelist);
    foreach my $line (@list) {
      # Get each drive's details
      next if $line =~ m/^\n/;
      refresh_window();
      my @drivedata = split(/\]\s\[/, $line);
      my $dev = $drivedata[0];
      $dev =~ s/\s*$//g;
      my $dev_name = $drivedata[1];
      $dev_name =~ s/\s*$//g;
      my $size = $drivedata[2];
      $size =~ s/^\s*//g;
      $size =~ s/\s+//g;
      if (!defined($size)) { $size = 'Unknown'; }
      my $enduser_drive_number = get_enduser_drive_number($dev);
      my ($base_device, $partition_number) = split_device_string($dev);
      my $type = get_drivetype($dev);
      my $desc = loc("Drive %1 (%2): %3",$enduser_drive_number,$size,$dev_name);
      if ($type eq 'usb') { $desc = loc("Drive %1 (%2): USB %3",$enduser_drive_number,$size,$dev_name); }
      $drives{$dev} = {
        'device'               => $dev,
        'enduser_drive_number' => $enduser_drive_number,
        'size'                 => $size,
        'model'                => $dev_name,
        'type'                 => $type,
        'desc'                 => $desc,
        'parts'                => {},
      };
    }
  }
  if (scalar(keys(%drives))==0) { return FALSE; }
  find_local_partitions();
  return TRUE;
}

sub find_local_partitions {
  # Set the list of local partitions for SCSI, USB and NVMe drives
  our %drives;
  set_busy(loc("Identifying disk drives..."));
  my $partlist = `fsarchiver probe 2>&1`;
  # For debug purposes, print the fsarchiver probe output.
  # TODO: Overhaul text processing to with clear, unit tested functions
  print("fsarchiver probe output:\n$partlist\n");
  chomp($partlist);
  if ($partlist =~ m/Failed to detect disks and filesystems/) {
    return FALSE;
  } else {
    # Create an array of partitions
    $partlist =~ s/^.*\[\=+DEVICE/\[\=DEVICE/s;
    $partlist =~ s/\[\=+DEVICE.*\n//g;
    $partlist =~ s/^\[|\]$//mg;
    my @list = split(/\n/, $partlist);
    foreach my $line (@list) {
      # Get each partition's details
      next if $line =~ m/^\n/;
      next if $line =~ m/^loop/;
      next if $line =~ m/^ramzswap/;
      next if $line =~ m/^dm-/;
      refresh_window();
      my ($partition, $fstype, $label, $size) = split(/\]\s\[/, $line);
      $partition = trim($partition);
      $fstype = trim("\U$fstype");
      $label = trim($label);
      $label = '' if $label eq '<unknown>';
      $size = trim($size);
      $size =~ s/\s+//g;
      my $enduser_drive_number = get_enduser_drive_number($partition);
      my ($dev, $partition_number) = split_device_string($partition);
      my $bytes = `cat /sys/block/$dev/$partition/size`;
      chomp($bytes);
      $bytes = abs(int($bytes*512));
      my $part = {
        'partition' => $partition,
        'partition_number' => $partition_number,
        'fstype'    => $fstype,
        'label'     => $label,
        'size'      => $size,
        'bytes'     => $bytes,
        'os'        => '',
      };
      # Save the details in a final list
      $drives{$dev}{'parts'}{$partition_number} = $part;
    }
    # Identify any operating systems
    refresh_window();
    # os-prober produces output in the form: (may vary on EFI vs non-EFI)
    # /dev/nvme0n1p1@/EFI/Microsoft/Boot/bootmgfw.efi:Windows Boot Manager:Windows:efi
    # TODO: Overhaul application and add unit tests
    my $oslist = `os-prober`;
    print("os-prober output:\n$oslist\n");
    chomp($oslist);
    if ($oslist ne "") {
      my @list = split(/\n/, $oslist);
      foreach my $line (@list) {
        my ($os_part, $os_name, $os_type, $os_loader) = split(/:/, $line);
        my ($device_node, $efi_bootloader) = split(/@/, $os_part);
        # Remove leading "/dev/"
        $device_node =~ s/^\/dev\///g;
        my ($dev, $partition_number) = split_device_string($device_node);
        if ($dev ne '') {
          $drives{$dev}{'parts'}{$partition_number}{'os'} = $os_name;
        }
      }
    }
  }
  # Update the drive description to include labels and OS types
  for my $dev (sort keys %drives) {
    if(ref($drives{$dev}{'parts'}) eq 'HASH') {
      for my $partition_number (sort keys %{ $drives{$dev}{'parts'} }) {
        my $desc = ' ';
        my $label = $drives{$dev}{'parts'}{$partition_number}{'label'};
        my $os = $drives{$dev}{'parts'}{$partition_number}{'os'};
        my $size = $drives{$dev}{'parts'}{$partition_number}{'size'};
        my $fstype = $drives{$dev}{'parts'}{$partition_number}{'fstype'};
        if ($os ne '') {
          $desc .= "($os, $size $fstype)";
        } else {
          if ($label ne '') {
            $desc .= "($label, $size $fstype)";
          } else {
            $desc .= "($size $fstype)";
          }
        }
        $drives{$dev}{'desc'} .= "$desc";
      }
    }
  }
  set_busy(FALSE);
  return TRUE;
}

sub find_shared_drives {
  # Search for local network shares (FTP/SMB)
  our %shares;
  set_busy(loc("Searching network for shared drives..."));
  refresh_window();
  my $smbdata = `smbtree -N | grep '\\\\\\\\\\w*\\\\\\w*[^\\\$] '`;
  refresh_window();
  chomp($smbdata);
  my @list = split(/\n/, $smbdata);
  foreach my $line (@list) {
    # Get list of SMB shared folders
    my ($share, $desc) = split(/  +/, $line);
    $share = trim($share);
    $desc = trim($desc);
    my ($a, $b, $host, $folder) = split(/\\/, $share);
    $host = trim("\U$host");
    $folder = trim("\U$folder");
    #my $ip = `nmblookup $host | grep '^[^q]'`;
    #$ip = trim($ip);
    #$ip =~ s/ .*$//g;
    my $ip = '';
    $shares{"smb://$host/$folder"} = {
      'ip'            => $ip,
      'host'          => $host,
      'folder'        => $folder,
      'desc'          => $desc,
      'type'          => 'SMB',
    };
  }
  my $subnet = get_subnet();
  refresh_window();
  system("nmap -p 21 $subnet/24 --open -T5 -oX /tmp/out.xml");
  refresh_window();
  my $xml = new XML::Simple;
  my $ftpdata = $xml->XMLin("/tmp/out.xml");
  foreach my $key (@{$ftpdata->{host}}) {
    my $state = $key->{ports}->{port}->{state}->{state};
    if (!defined($state)) { $state = ''; }
    if ($state eq 'open') {
      my $ip = '';
      my $vendor = '';
      my $hostname = '';
      if (ref($key->{address}) eq 'ARRAY') {
        foreach my $address_key (@{$key->{address}}) {
          if ($address_key->{addrtype} eq 'ipv4') { $ip = $address_key->{addr}; }
          if ($address_key->{addrtype} eq 'mac') { $vendor = $address_key->{vendor}; }
        }
      } else {
        $ip = $key->{address}->{ip};
        $vendor = '';
      }
      if (ref($key->{hostnames}->{hostname}) eq 'ARRAY') {
        foreach my $hostname_key (@{$key->{hostnames}}) {
          if ($hostname_key->{type} eq 'PTR') { $hostname = $hostname_key->{name}; }
        }
      } else {
        $hostname = $key->{hostnames}->{hostname}->{name};
      }
      $shares{"ftp://$ip"} = {
        'ip'            => $ip,
        'host'          => $hostname,
        'folder'        => '',
        'desc'          => $vendor,
        'type'          => 'FTP',
      };
    }
  }
  set_busy(FALSE);
  return TRUE;
}

sub scan_network {
  # Scan the network and add shares to given dropdown
  my $cbo = our $builder->get_object($_[0]);
  my $mdl = $cbo->get_model();
  $mdl->clear();
  find_shared_drives();
  print_share_list();
  set_share_dropdown($_[0]);
}

sub get_enduser_drive_number {
  # For a given partition, query the devices in the kernel and return a drive number that can be associated with
  # the partition's base device.
  #
  # Warning: insertion of new devices (eg, inserting USB drive /dev/sdc) may change the drive number of existing
  # drives, so this integer must ONLY BE USED FOR DISPLAY PURPOSES (NOT in backup/restore operations)
  #
  # Input arguments:
  #   input_partition: the partition device node. Eg, 'sda5' or 'nvme0n1p3'
  #                    The base device node associated with this partition (eg sda or nvme0n1) MUST exist on the
  #                    current system, as the kernel state is queried (via lsblk)
  # 
  # Returns:
  #   * Human-readable drive number (-1 on error)
  #         For display to the target end-user (who may find UNIX device strings unfamiliar and intimidating.
  my $input_partition = $_[0];

  # List block devices, and extract the "internal parent kernel device name", ie the base device node.
  my $base_device = `lsblk --noheadings --output=pkname --nodeps /dev/$input_partition`;
  my $lsblk_exit_code = $?;
  if ($lsblk_exit_code == 0) {
    # The list block returned success.
    chomp($base_device);
    # If "internal parent kernel device name" field is empty, we assume input was already the base device.
    if (("$base_device" cmp "") == 0) {
      $base_device = $input_partition;
    }
  } elsif ($lsblk_exit_code == 1) {
    # Error log message relevant only for developers, no need to localize them for enduser not familiar with Linux.
    print "lsblk reported error.\n";
    return -1;
  } elsif ($lsblk_exit_code == 32) {
    print "lsblk reported none of the specified partitions found for /dev/$input_partition\n";
    return -1;
  } elsif ($lsblk_exit_code == 64) {
    print "lsblk reported only some of the specified partitions found for /dev/$input_partition\n";
    return -1;
  } else {
    print "lsblk encountered unexpected error.\n";
    return -1;
  }

  # Calculate human-readable drive number from the output of lsblk 
  my $enduser_drive_number = -1;
  # Array containing all the base device strings
  my @all_base_devices = split /\n/, `lsblk --noheadings --output=name --nodeps`;
  # Drive number for enduser display starting from 1, rather than 0;
  my $index = 1;
  foreach my $candidate_base_device (@all_base_devices) {
    if ($candidate_base_device =~ /$base_device/) {
      $enduser_drive_number = $index;
    }
    $index++;
  }
  if ($enduser_drive_number == -1) {
    # Error log message relevant only for developers, no need to localize them for enduser not familiar with Linux.
    print "Could not find $base_device string in: @all_base_devices\n";
    return -1;
  }

  return $enduser_drive_number;
}

sub split_device_string {
  # For a given partition, use regular expressions to return the UNIX base device node string,
  # and the partition number.
  #
  # Input arguments:
  #   input_partition: A partition device string. Eg, 'sda5', 'nvme0n1p3'.
  #                    For the purposes of this function the partition device node (eg, '/dev/sda5' or '/dev/nvme0n1p3'),
  #                    and its base device node (eg, '/dev/sda' or '/dev/nvme0n1') do NOT need to be present.
  #                    Note: Do NOT pass input with regex characters (like forward slash or asterisk wildcards).
  #
  # Returns:
  #   List in the form (sda, 5) or (nvme0n1, 3), which contains:
  #     * The base device node
  #     * Partition number (eg. 5 from "sda5" or 3 from "nvme0n1p3")
  my $input_partition = $_[0];

  # Get the partition number by removing everything from the start of the line until the final alphabetical letter.
  # Eg, get the '5' from sda5 or the '3' from nvme0n1p3.
  my $partition_number = $input_partition;
  $partition_number =~ s/.*[a-zA-Z]//;
  if ($partition_number eq "") {
    # Error log message relevant only for developers, no need to localize them for enduser not familiar with Linux.
    print "Input partition $input_partition could not be parsed.\n";
  } else {
    $partition_number = int($partition_number);
  }

  my $base_device = $input_partition;
  # Get the base device using a regex pattern (the contents of the parenthesis is returned, ie a regex capturing group)
  if ($base_device =~ /nvme.*/) {
    # From nvme0n1p3, delete everything after the 'p', including the 'p'
    $base_device =~ s/p.*//;
  } else {
    # Delete all numeric characters.
    $base_device =~ s/[0-9]+.*//;
  }

  return ($base_device, $partition_number);
}

sub join_device_string {
  # Given a UNIX base device node string, and an end-user friendly partition number
  # r returns a combined string that handles NVMe's device naming style in addition to the style used by SATA and
  # PATA devices.
  #
  # Input arguments:
  #   base_device_node         : Eg, 'sda' or 'nvme0n1'.
  #   partition_number : Eg, '5' or '3'
  #
  # Returns:
  #     * combined string      : Eg, 'sda5' or 'nvme0n1p3' (notice the 'p' for the NVMe drive)
  my $base_device_node = $_[0];
  my $partition_number = $_[1];

  my $joined = "";
  if ($base_device_node =~ /nvme.*/) {
    # If the target device node is an NVMe drive, append the letter 'p' (nvme0n1p3)
    $joined = "${base_device_node}p${partition_number}";
  } else {
    $joined = $base_device_node.$partition_number;
  }
  return $joined;
}

sub save_partition_list {
  # Takes an array containing a list of partitions and saves it to an output file. More recent device node patterns,
  # such as NVMe drives' nvmeAnBpC are rewritten in the format sdzC to preserve the compatibility of Rescuezilla v1.0.5
  # to be able to restore NVMe partitions to non-NVMe drives as it processes the source partition list during a
  # restore operation.
  #
  # Input arguments:
  #   partition array: An array containing the partitions being backed up. Eg, 'sda1', 'sda2', 'sda3'.
  #   output file: Output file to write the partitions separated by a newline (\n)
  my @partitions = @{$_[0]};
  my $output_file = $_[1];

  foreach my $part (@partitions) {
     # During a restore process, the original partition string is processed. Given Rescuezilla v1.0.5 does not
     # support the NVMe drive pattern (nvmeAnBpC), rewriting any NVMe drive patterns to an sdzC pattern means that
     # Rescuezilla v1.0.5 is able to restore partitions which were originally backed up from an NVMe devices by
     # newer version of Rescuezilla.
     if ($part =~ /nvme.*/) {
       my ($original_base_device, $original_partition_number) = split_device_string($part);
       $part = join_device_string("sdz", $original_partition_number);
     }
  }

  # Convert array into string with line breaks after each partition
  my $linebroken_partition_string = join("\n", @partitions);
  save_file($linebroken_partition_string, $output_file);
  print "\t* ".loc("Partition list saved to %1",$output_file)."\n";
}


sub get_drivetype {
  # Given an "sdX" device, return the string that indicates its type
  my $dev = $_[0];
  my $usb = `ls -asl /dev/disk/by-id/ | grep '$dev\$' | grep 'usb' | wc -l`;
  if ($usb==1) {
    return 'usb';
  } else {
    return 'scsi';
  }
}

sub get_subnet {
  # Return current subnet for my IP address
  my $ip = `ifconfig -a | perl -ne 'if ( m/^\\s*inet (?:addr:)?([\\d.]+).*?cast/ ) { print qq(\$1\\n); exit 0; }'`;
  chomp($ip);
  my ($a,$b,$c) = split(/\./, $ip);
  return "$a.$b.$c.0";
}

sub trim {
  # Trim whitespace from both ends of a string
  my $string = shift;
  $string =~ s/^\s+//;
  $string =~ s/\s+$//;
  return $string;
}

sub get_free_space {
  # Return free space left on destination drive
  my $mb = shift;
  my $mount_point = MOUNT_POINT;
  my $cmd = '';
  if ((defined($mb))&&($mb==1)) {
    $cmd = "--block-size=1M";
  } else {
    $cmd = "-h";
  }
  my ($null1, $null2, $null3, $free) = split(/\s+/, `df $cmd $mount_point | tail -n 1`);
  print loc("Free space: %1",$free)."\n";
  return $free;
}

sub beeper {
  # Play a system beep pattern
  my $tone = shift;
  my $args = '';
  if ($tone eq 'done') { $args = '-l 100 -f 1200 -n -l 100 -f 1800 -n -l 100 -f 2400'; }
  if ($tone eq 'warning') { $args = '-f 250 -r 3 -l 50'; }
  if ($tone eq 'error') { $args = '-l 1000 -f 100'; }
  system('beep '.$args);
  return 1;
}

sub format_size {
  # Given a size in bytes, make it human-readable
  my $bytes = $_[0];
  my $suffix = "";
  my $x = log($bytes) / log(10);
  if ($x<3) {
    $suffix = loc(" bytes");
  } elsif ($x<6) {
    $x = 3;
    $suffix = "KB";
  } elsif ($x<9) {
    $x = 6;
    $suffix = "MB";
  } elsif ($x<12) {
    $x = 9;
    $suffix = "GB";
  } elsif ($x<15) {
    $x = 12;
    $suffix = "TB";
  } else {
    $x = 15;
    $suffix = "PB";
  }
  return sprintf("%0.1f", $bytes/(10**$x)).$suffix;
}

sub check_command {
  # Check given command correctly executes with exit code zero, fatal crash otherwise.
  #
  # TODO: Make this not do a fatal crash, but return instead
  #
  # Input arguments:
  #   cmd: Command to run. Eg 'ls --version'
  my $cmd = $_[0];

  my $tool_stdout = "";
  my $tool_stderr = "";
  my $tool_retcode = 0;
  ($tool_stdout, $tool_stderr, $tool_retcode) = capture { system($cmd); };
  print("$cmd ($tool_retcode):\n$tool_stdout\n\n$tool_stderr");
  if ($tool_retcode != 0) {
    my $tool_failed_msg = loc("Failed to run command: %1\n%2\n%3", $cmd, $tool_stderr, $tool_stdout);
    fatal_crash($tool_failed_msg);
  }
}
